
#include "VSFilterImpl.h"

#include "VSFilter.h"

#include "FileHandle.h"

#include "MemSubPicEx.h"
#include "SubPicQueueImpl.h"
#include "VobSubFile.h"
#include "RTS.h"
#include "RenderedHdmvSubtitle.h"
#include "SubtitleInputPin.h"
#include "vd.h"
#include <new>

#include <WXMediaCpp.h>

namespace FileVersion
{
	// major.minor.build.revision
	union Ver {
		UINT64 value = 0;
		struct {
			UINT16 revision;
			UINT16 build;
			UINT16 minor;
			UINT16 major;
		};

		constexpr Ver(UINT64 _value)
			: value(_value)
		{
		}

		constexpr Ver(UINT16 _major, UINT16 _minor, UINT16 _build, UINT16 _revision)
			: major(_major), minor(_minor), build(_build), revision(_revision)
		{
		}
	};

	static Ver GetVer(LPCWSTR wstrFilename)
	{
		Ver ver(0, 0, 0, 0);

		const DWORD len = LibInst::GetInst().mGetFileVersionInfoSizeW(wstrFilename, nullptr);
		if (len) {
			WCHAR* buf = new  WCHAR[len];
			if (buf) {
				UINT uLen;
				VS_FIXEDFILEINFO* pvsf = nullptr;
				if (LibInst::GetInst().mGetFileVersionInfoW(wstrFilename, 0, len, buf) && LibInst::GetInst().mVerQueryValueW(buf, L"\\", (LPVOID*)&pvsf, &uLen)) {
					ver.value = ((UINT64)pvsf->dwFileVersionMS << 32) | pvsf->dwFileVersionLS;
				}

				delete[] buf;
			}
		}

		return ver;
	}
}



#ifdef _M_IX86 
extern "C" {
	int _afxForceUSRDLL;
}
#else 
extern "C" {
	int __afxForceUSRDLL;
}
#endif







extern void Scale2x(const GUID& subtype, BYTE* d, int dpitch, BYTE* s, int spitch, int w, int h);

extern int c2y_yb[256];
extern int c2y_yg[256];
extern int c2y_yr[256];
extern void ColorConvInit();

CDirectVobSub::CDirectVobSub()
{
#ifdef _DEBUG
	DbgSetModuleLevel(LOG_TRACE, DWORD_MAX);
	DbgSetModuleLevel(LOG_ERROR, DWORD_MAX);
#endif

	BYTE* pData = NULL;
	//UINT nSize;

	m_iSelectedLanguage = 0;
	m_bHideSubtitles = 0;
	//m_uSubPictToBuffer = 10;
	m_uSubPictToBuffer = 0;
	m_bAnimWhenBuffering = 1;
	m_bAllowDropSubPic = 1;
	m_bOverridePlacement = 0;
	m_PlacementXperc = 50;
	m_PlacementYperc = 90;
	m_bBufferVobSub = 1;
	m_bOnlyShowForcedVobSubs = 0;
	m_bPolygonize = 0;
	//CString sss = L"";
	std::wstring wsss = L"";
	m_defStyle <<= wsss;
	m_bFlipPicture = 0;
	m_bFlipSubtitles = 0;
	m_bOSD = 0;
	m_bSaveFullPath = 0;
	m_nReloaderDisableCount = 1;
	m_SubtitleDelay = 0;
	m_SubtitleSpeedMul = 1000;
	m_SubtitleSpeedDiv = 1000;
	m_bMediaFPSEnabled = 0;
	m_ePARCompensationType = EPCTDisabled;
	pData = nullptr;
	m_MediaFPS = 25.0;
	m_ZoomRect.left = m_ZoomRect.top = 0;
	m_ZoomRect.right = m_ZoomRect.bottom = 1;

	m_bForced = false;
}

CDirectVobSub::~CDirectVobSub()
{
	DSAutoLock cAutoLock(&m_propsLock);
}

STDMETHODIMP CDirectVobSub::get_FileName(WCHAR* fn)
{
	DSAutoLock cAutoLock(&m_propsLock);

	if (!fn) {
		return E_POINTER;
	}

	wcscpy_s(fn, MAX_PATH, m_FileName.GetString());

	return S_OK;
}

STDMETHODIMP CDirectVobSub::put_FileName(WCHAR* fn)
{
	DSAutoLock cAutoLock(&m_propsLock);

	if (!fn) {
		return E_POINTER;
	}

	CString tmp = fn;
	if (!m_FileName.Left(m_FileName.ReverseFind('.') + 1).CompareNoCase(tmp.Left(tmp.ReverseFind('.') + 1))) {
		return S_FALSE;
	}

	m_FileName = fn;

	return S_OK;
}

STDMETHODIMP CDirectVobSub::get_LanguageCount(int* nLangs)
{
	DSAutoLock cAutoLock(&m_propsLock);

	return nLangs ? *nLangs = 0, S_OK : E_POINTER;
}

STDMETHODIMP CDirectVobSub::get_LanguageName(int iLanguage, WCHAR** ppName)
{
	return S_OK;
}

STDMETHODIMP CDirectVobSub::get_SelectedLanguage(int* iSelected)
{
	DSAutoLock cAutoLock(&m_propsLock);

	return iSelected ? *iSelected = m_iSelectedLanguage, S_OK : E_POINTER;
}

STDMETHODIMP CDirectVobSub::put_SelectedLanguage(int iSelected)
{
	DSAutoLock cAutoLock(&m_propsLock);

	if (m_iSelectedLanguage == iSelected) {
		return S_FALSE;
	}

	int nCount;
	if (FAILED(get_LanguageCount(&nCount))
		|| iSelected < 0
		|| iSelected >= nCount) {
		return E_FAIL;
	}

	m_iSelectedLanguage = iSelected;

	return S_OK;
}

STDMETHODIMP CDirectVobSub::get_HideSubtitles(bool* fHideSubtitles)
{
	DSAutoLock cAutoLock(&m_propsLock);

	return fHideSubtitles ? *fHideSubtitles = m_bHideSubtitles, S_OK : E_POINTER;
}

STDMETHODIMP CDirectVobSub::put_HideSubtitles(bool fHideSubtitles)
{
	DSAutoLock cAutoLock(&m_propsLock);

	if (m_bHideSubtitles == fHideSubtitles) {
		return S_FALSE;
	}

	m_bHideSubtitles = fHideSubtitles;

	return S_OK;
}

// deprecated
STDMETHODIMP CDirectVobSub::get_PreBuffering(bool* fDoPreBuffering)
{
	DSAutoLock cAutoLock(&m_propsLock);

	return fDoPreBuffering ? *fDoPreBuffering = (m_uSubPictToBuffer > 0), S_OK : E_POINTER;
}

// deprecated
STDMETHODIMP CDirectVobSub::put_PreBuffering(bool fDoPreBuffering)
{
	DSAutoLock cAutoLock(&m_propsLock);

	if ((m_uSubPictToBuffer > 0) == fDoPreBuffering) {
		return S_FALSE;
	}

	m_uSubPictToBuffer = fDoPreBuffering ? 4 : 0; // 4 is the default value for SubPictToBuffer

	return S_OK;
}

STDMETHODIMP CDirectVobSub::get_SubPictToBuffer(unsigned int* uSubPictToBuffer)
{
	DSAutoLock cAutoLock(&m_propsLock);

	return uSubPictToBuffer ? *uSubPictToBuffer = m_uSubPictToBuffer, S_OK : E_POINTER;
}

STDMETHODIMP CDirectVobSub::put_SubPictToBuffer(unsigned int uSubPictToBuffer)
{
	DSAutoLock cAutoLock(&m_propsLock);

	if (m_uSubPictToBuffer == uSubPictToBuffer) {
		return S_FALSE;
	}

	m_uSubPictToBuffer = uSubPictToBuffer;

	return S_OK;
}

STDMETHODIMP CDirectVobSub::get_AnimWhenBuffering(bool* fAnimWhenBuffering)
{
	DSAutoLock cAutoLock(&m_propsLock);

	return fAnimWhenBuffering ? *fAnimWhenBuffering = m_bAnimWhenBuffering, S_OK : E_POINTER;
}

STDMETHODIMP CDirectVobSub::put_AnimWhenBuffering(bool fAnimWhenBuffering)
{
	DSAutoLock cAutoLock(&m_propsLock);

	if (m_bAnimWhenBuffering == fAnimWhenBuffering) {
		return S_FALSE;
	}

	m_bAnimWhenBuffering = fAnimWhenBuffering;

	return S_OK;
}

STDMETHODIMP CDirectVobSub::get_AllowDropSubPic(bool* fAllowDropSubPic)
{
	DSAutoLock cAutoLock(&m_propsLock);

	return fAllowDropSubPic ? *fAllowDropSubPic = m_bAllowDropSubPic, S_OK : E_POINTER;
}

STDMETHODIMP CDirectVobSub::put_AllowDropSubPic(bool fAllowDropSubPic)
{
	DSAutoLock cAutoLock(&m_propsLock);

	if (m_bAllowDropSubPic == fAllowDropSubPic) {
		return S_FALSE;
	}

	m_bAllowDropSubPic = fAllowDropSubPic;

	return S_OK;
}

STDMETHODIMP CDirectVobSub::get_Placement(bool* fOverridePlacement, int* xperc, int* yperc)
{
	DSAutoLock cAutoLock(&m_propsLock);

	if (fOverridePlacement) {
		*fOverridePlacement = m_bOverridePlacement;
	}
	if (xperc) {
		*xperc = m_PlacementXperc;
	}
	if (yperc) {
		*yperc = m_PlacementYperc;
	}

	return S_OK;
}

STDMETHODIMP CDirectVobSub::put_Placement(bool fOverridePlacement, int xperc, int yperc)
{
	DSAutoLock cAutoLock(&m_propsLock);

	if (m_bOverridePlacement == fOverridePlacement && m_PlacementXperc == xperc && m_PlacementYperc == yperc) {
		return S_FALSE;
	}

	m_bOverridePlacement = fOverridePlacement;
	m_PlacementXperc = xperc;
	m_PlacementYperc = yperc;

	return S_OK;
}

STDMETHODIMP CDirectVobSub::get_VobSubSettings(bool* fBuffer, bool* fOnlyShowForcedSubs, bool* fPolygonize)
{
	DSAutoLock cAutoLock(&m_propsLock);

	if (fBuffer) {
		*fBuffer = m_bBufferVobSub;
	}
	if (fOnlyShowForcedSubs) {
		*fOnlyShowForcedSubs = m_bOnlyShowForcedVobSubs;
	}
	if (fPolygonize) {
		*fPolygonize = m_bPolygonize;
	}

	return S_OK;
}

STDMETHODIMP CDirectVobSub::put_VobSubSettings(bool fBuffer, bool fOnlyShowForcedSubs, bool fPolygonize)
{
	DSAutoLock cAutoLock(&m_propsLock);

	if (m_bBufferVobSub == fBuffer && m_bOnlyShowForcedVobSubs == fOnlyShowForcedSubs && m_bPolygonize == fPolygonize) {
		return S_FALSE;
	}

	m_bBufferVobSub = fBuffer;
	m_bOnlyShowForcedVobSubs = fOnlyShowForcedSubs;
	m_bPolygonize = fPolygonize;

	return S_OK;
}

STDMETHODIMP CDirectVobSub::get_TextSettings(void* lf, int lflen, COLORREF* color, bool* fShadow, bool* fOutline, bool* fAdvancedRenderer)
{
	DSAutoLock cAutoLock(&m_propsLock);

	if (lf) {
		if (lflen == sizeof(LOGFONTW)) {
			wcsncpy_s(((LOGFONTW*)lf)->lfFaceName, LF_FACESIZE, CStringW(m_defStyle.fontNameW.c_str()), _TRUNCATE);
		}
		else {
			return E_INVALIDARG;
		}

		((LOGFONT*)lf)->lfCharSet = m_defStyle.charSet;
		((LOGFONT*)lf)->lfItalic = m_defStyle.fItalic;
		((LOGFONT*)lf)->lfHeight = m_defStyle.fontSize;
		((LOGFONT*)lf)->lfWeight = m_defStyle.fontWeight;
		((LOGFONT*)lf)->lfStrikeOut = m_defStyle.fStrikeOut;
		((LOGFONT*)lf)->lfUnderline = m_defStyle.fUnderline;
	}

	if (color) {
		*color = m_defStyle.colors[0];
	}
	if (fShadow) {
		*fShadow = (m_defStyle.shadowDepthX != 0) || (m_defStyle.shadowDepthY != 0);
	}
	if (fOutline) {
		*fOutline = (m_defStyle.outlineWidthX + m_defStyle.outlineWidthY) > 0;
	}
	if (fAdvancedRenderer) {
		*fAdvancedRenderer = m_bAdvancedRenderer;
	}

	return S_OK;
}

STDMETHODIMP CDirectVobSub::put_TextSettings(void* lf, int lflen, COLORREF color, bool fShadow, bool fOutline, bool fAdvancedRenderer)
{
	DSAutoLock cAutoLock(&m_propsLock);

	if (lf) {
		if (lflen == sizeof(LOGFONTA)) {
			CStringA sa = ((LOGFONTA*)lf)->lfFaceName;
			// m_defStyle.fontNameW = sa;// char to wchar_t  ��ʱ��֧��
		}
		else if (lflen == sizeof(LOGFONTW)) {
			m_defStyle.fontNameW = ((LOGFONTW*)lf)->lfFaceName;
		}
		else {
			return E_INVALIDARG;
		}

		m_defStyle.charSet = ((LOGFONT*)lf)->lfCharSet;
		m_defStyle.fItalic = !!((LOGFONT*)lf)->lfItalic;
		m_defStyle.fontSize = ((LOGFONT*)lf)->lfHeight;
		m_defStyle.fontWeight = ((LOGFONT*)lf)->lfWeight;
		m_defStyle.fStrikeOut = !!((LOGFONT*)lf)->lfStrikeOut;
		m_defStyle.fUnderline = !!((LOGFONT*)lf)->lfUnderline;

		if (m_defStyle.fontSize < 0) {
			HDC hdc = ::GetDC(0);
			m_defStyle.fontSize = -m_defStyle.fontSize * 72 / GetDeviceCaps(hdc, LOGPIXELSY);
			::ReleaseDC(0, hdc);
		}

	}

	m_defStyle.colors[0] = color;
	m_defStyle.shadowDepthX = m_defStyle.shadowDepthY = fShadow ? 2 : 0;
	m_defStyle.outlineWidthX = m_defStyle.outlineWidthY = fOutline ? 2 : 0;

	return S_OK;

}

STDMETHODIMP CDirectVobSub::get_Flip(bool* fPicture, bool* fSubtitles)
{
	DSAutoLock cAutoLock(&m_propsLock);

	if (fPicture) {
		*fPicture = m_bFlipPicture;
	}
	if (fSubtitles) {
		*fSubtitles = m_bFlipSubtitles;
	}

	return S_OK;
}

STDMETHODIMP CDirectVobSub::put_Flip(bool fPicture, bool fSubtitles)
{
	DSAutoLock cAutoLock(&m_propsLock);

	if (m_bFlipPicture == fPicture && m_bFlipSubtitles == fSubtitles) {
		return S_FALSE;
	}

	m_bFlipPicture = fPicture;
	m_bFlipSubtitles = fSubtitles;

	return S_OK;
}

STDMETHODIMP CDirectVobSub::get_OSD(bool* fOSD)
{
	DSAutoLock cAutoLock(&m_propsLock);

	return fOSD ? *fOSD = m_bOSD, S_OK : E_POINTER;
}

STDMETHODIMP CDirectVobSub::put_OSD(bool fOSD)
{
	DSAutoLock cAutoLock(&m_propsLock);

	if (m_bOSD == fOSD) {
		return S_FALSE;
	}

	m_bOSD = fOSD;

	return S_OK;
}

STDMETHODIMP CDirectVobSub::get_SaveFullPath(bool* fSaveFullPath)
{
	DSAutoLock cAutoLock(&m_propsLock);

	return fSaveFullPath ? *fSaveFullPath = m_bSaveFullPath, S_OK : E_POINTER;
}

STDMETHODIMP CDirectVobSub::put_SaveFullPath(bool fSaveFullPath)
{
	DSAutoLock cAutoLock(&m_propsLock);

	if (m_bSaveFullPath == fSaveFullPath) {
		return S_FALSE;
	}

	m_bSaveFullPath = fSaveFullPath;

	return S_OK;
}

STDMETHODIMP CDirectVobSub::get_SubtitleTiming(int* delay, int* speedmul, int* speeddiv)
{
	DSAutoLock cAutoLock(&m_propsLock);

	if (delay) {
		*delay = m_SubtitleDelay;
	}
	if (speedmul) {
		*speedmul = m_SubtitleSpeedMul;
	}
	if (speeddiv) {
		*speeddiv = m_SubtitleSpeedDiv;
	}

	return S_OK;
}

STDMETHODIMP CDirectVobSub::put_SubtitleTiming(int delay, int speedmul, int speeddiv)
{
	DSAutoLock cAutoLock(&m_propsLock);

	if (m_SubtitleDelay == delay && m_SubtitleSpeedMul == speedmul && m_SubtitleSpeedDiv == speeddiv) {
		return S_FALSE;
	}

	m_SubtitleDelay = delay;
	m_SubtitleSpeedMul = speedmul;
	if (speeddiv > 0) {
		m_SubtitleSpeedDiv = speeddiv;
	}

	return S_OK;
}

STDMETHODIMP CDirectVobSub::get_MediaFPS(bool* fEnabled, double* fps)
{
	DSAutoLock cAutoLock(&m_propsLock);

	if (fEnabled) {
		*fEnabled = m_bMediaFPSEnabled;
	}
	if (fps) {
		*fps = m_MediaFPS;
	}

	return S_OK;
}

STDMETHODIMP CDirectVobSub::put_MediaFPS(bool fEnabled, double fps)
{
	DSAutoLock cAutoLock(&m_propsLock);

	if (m_bMediaFPSEnabled == fEnabled && m_MediaFPS == fps) {
		return S_FALSE;
	}

	m_bMediaFPSEnabled = fEnabled;
	if (fps > 0) {
		m_MediaFPS = fps;
	}

	return S_OK;
}

STDMETHODIMP CDirectVobSub::get_ZoomRect(NORMALIZEDRECT* rect)
{
	DSAutoLock cAutoLock(&m_propsLock);

	if (!rect) {
		return E_POINTER;
	}

	*rect = m_ZoomRect;

	return S_OK;
}

STDMETHODIMP CDirectVobSub::put_ZoomRect(NORMALIZEDRECT* rect)
{
	DSAutoLock cAutoLock(&m_propsLock);

	if (!rect) {
		return E_POINTER;
	}

	if (!memcmp(&m_ZoomRect, rect, sizeof(m_ZoomRect))) {
		return S_FALSE;
	}

	m_ZoomRect = *rect;

	return S_OK;
}

STDMETHODIMP CDirectVobSub::UpdateRegistry()
{
	return S_OK;
}

STDMETHODIMP CDirectVobSub::HasConfigDialog(int iSelected)
{
	return E_NOTIMPL;
}

STDMETHODIMP CDirectVobSub::ShowConfigDialog(int iSelected, HWND hWndParent)
{
	return E_NOTIMPL;
}

STDMETHODIMP CDirectVobSub::IsSubtitleReloaderLocked(bool* fLocked)
{
	DSAutoLock cAutoLock(&m_propsLock);

	if (!fLocked) {
		return E_POINTER;
	}

	bool fDisabled;
	get_SubtitleReloader(&fDisabled);

	*fLocked = fDisabled || m_nReloaderDisableCount > 0;

	return S_OK;
}

STDMETHODIMP CDirectVobSub::LockSubtitleReloader(bool fLock)
{
	DSAutoLock cAutoLock(&m_propsLock);

	if (fLock) {
		m_nReloaderDisableCount++;
	}
	else {
		m_nReloaderDisableCount--;
	}

	ASSERT(m_nReloaderDisableCount >= 0);
	if (m_nReloaderDisableCount < 0) {
		m_nReloaderDisableCount = 0;
	}

	return S_OK;
}

STDMETHODIMP CDirectVobSub::get_SubtitleReloader(bool* fDisabledReloader)
{
	DSAutoLock cAutoLock(&m_propsLock);

	if (fDisabledReloader) {
		*fDisabledReloader = m_fDisabledReloader;
	}
	return S_OK;
}

STDMETHODIMP CDirectVobSub::put_SubtitleReloader(bool fDisabledReloader)
{
	DSAutoLock cAutoLock(&m_propsLock);

	bool b;
	get_SubtitleReloader(&b);
	if (b == fDisabledReloader) {
		return S_FALSE;
	}

	m_fDisabledReloader = fDisabledReloader;
	return S_OK;
}

STDMETHODIMP CDirectVobSub::get_ExtendPicture(int* horizontal, int* vertical, int* resx2, int* resx2minw, int* resx2minh)
{
	DSAutoLock cAutoLock(&m_propsLock);

	if (horizontal) {
		*horizontal = m_horizontal;
	}
	if (vertical) {
		*vertical = m_vertical;
	}
	if (resx2) {
		*resx2 = 0;
	}
	if (resx2minw) {
		*resx2minw = m_resx2minw;
	}
	if (resx2minh) {
		*resx2minh = m_resx2minh;
	}

	return S_OK;
}

STDMETHODIMP CDirectVobSub::put_ExtendPicture(int horizontal, int vertical, int resx2, int resx2minw, int resx2minh)
{
	DSAutoLock cAutoLock(&m_propsLock);

	int i[5];
	get_ExtendPicture(i, i + 1, i + 2, i + 3, i + 4);
	if (i[0] == horizontal && i[1] == vertical && i[2] == resx2 && i[3] == resx2minw && i[4] == resx2minh) {
		return S_FALSE;
	}
	m_horizontal = horizontal & 1;
	m_vertical = vertical;
	m_resx2 = resx2 & 3;
	m_resx2minw = resx2minw;
	m_resx2minh = resx2minh;
	return S_OK;
}

STDMETHODIMP CDirectVobSub::get_LoadSettings(int* level, bool* fExternalLoad, bool* fWebLoad, bool* fEmbeddedLoad)
{
	DSAutoLock cAutoLock(&m_propsLock);

	if (level) {
		*level = m_level;
	}
	if (fExternalLoad) {
		*fExternalLoad = m_fExternalLoad;
	}
	if (fWebLoad) {
		*fWebLoad = m_fWebLoad;
	}
	if (fEmbeddedLoad) {
		*fEmbeddedLoad = m_fEmbeddedLoad;
	}

	return S_OK;
}

STDMETHODIMP CDirectVobSub::put_LoadSettings(int level, bool fExternalLoad, bool fWebLoad, bool fEmbeddedLoad)
{
	DSAutoLock cAutoLock(&m_propsLock);

	int i;
	bool b[3];
	get_LoadSettings(&i, b, b + 1, b + 2);
	if (i == level && b[0] == fExternalLoad && b[1] == fWebLoad && b[2] == fEmbeddedLoad) {
		return S_FALSE;
	}
	m_level = level & 3;
	m_fExternalLoad = fExternalLoad;
	m_fWebLoad = fWebLoad;
	m_fEmbeddedLoad = fEmbeddedLoad;
	return S_OK;
}

// IDirectVobSub2

STDMETHODIMP CDirectVobSub::AdviseSubClock(ISubClock* pSubClock)
{
	m_pSubClock = pSubClock;
	return S_OK;
}

STDMETHODIMP_(bool) CDirectVobSub::get_Forced()
{
	return m_bForced;
}

STDMETHODIMP CDirectVobSub::put_Forced(bool fForced)
{
	m_bForced = fForced;
	return S_OK;
}

STDMETHODIMP CDirectVobSub::get_TextSettings(STSStyle* pDefStyle)
{
	CheckPointer(pDefStyle, E_POINTER);

	DSAutoLock cAutoLock(&m_propsLock);

	*pDefStyle = m_defStyle;

	return S_OK;
}

STDMETHODIMP CDirectVobSub::put_TextSettings(STSStyle* pDefStyle)
{
	CheckPointer(pDefStyle, E_POINTER);

	DSAutoLock cAutoLock(&m_propsLock);

	if (m_defStyle == *pDefStyle) {
		return S_FALSE;
	}

	m_defStyle = *pDefStyle;

	return S_OK;
}

STDMETHODIMP CDirectVobSub::get_AspectRatioSettings(EPARCompensationType* ePARCompensationType)
{
	DSAutoLock cAutoLock(&m_propsLock);

	*ePARCompensationType = m_ePARCompensationType;

	return S_OK;
}

STDMETHODIMP CDirectVobSub::put_AspectRatioSettings(EPARCompensationType* ePARCompensationType)
{
	DSAutoLock cAutoLock(&m_propsLock);

	m_ePARCompensationType = *ePARCompensationType;

	return S_OK;
}


static const VIDEO_OUTPUT_FORMATS VSFilterDefaultFormats[] = {
	{&MEDIASUBTYPE_YV12,  FCC('YV12'),  12, 1},
	{&MEDIASUBTYPE_NV12,  FCC('NV12'),  12, 1},
	{&MEDIASUBTYPE_YUY2,  FCC('YUY2'),  16, 2},
	{&MEDIASUBTYPE_I420,  FCC('I420'),  12, 1},
	{&MEDIASUBTYPE_IYUV,  FCC('IYUV'),  12, 1},
	{&MEDIASUBTYPE_ARGB32,BI_RGB,       32, 4},
	{&MEDIASUBTYPE_RGB32, BI_RGB,       32, 4},
	{&MEDIASUBTYPE_RGB24, BI_RGB,       24, 3},
	{&MEDIASUBTYPE_RGB565,BI_RGB,       16, 2},
	{&MEDIASUBTYPE_RGB555,BI_RGB,       16, 2},
	{&MEDIASUBTYPE_ARGB32,BI_BITFIELDS, 32, 4},
	{&MEDIASUBTYPE_RGB32, BI_BITFIELDS, 32, 4},
	{&MEDIASUBTYPE_RGB24, BI_BITFIELDS, 24, 3},
	{&MEDIASUBTYPE_RGB565,BI_BITFIELDS, 16, 2},
	{&MEDIASUBTYPE_RGB555,BI_BITFIELDS, 16, 2},
	{&MEDIASUBTYPE_P010,  FCC('P010'),  24, 2},
	{&MEDIASUBTYPE_P016,  FCC('P016'),  24, 2},
};

LPCWSTR MediaSubtype2String(const GUID& subtype);

void BltLineRGB32(DWORD* d, BYTE* sub, int w, const GUID& subtype)
{
	if (subtype == MEDIASUBTYPE_YV12 || subtype == MEDIASUBTYPE_I420 || subtype == MEDIASUBTYPE_IYUV
		|| subtype == MEDIASUBTYPE_NV12) {
		BYTE* db = (BYTE*)d;
		BYTE* dbtend = db + w;

		for (; db < dbtend; sub += 4, db++) {
			if (sub[3] < 0xff) {
				int y = (c2y_yb[sub[0]] + c2y_yg[sub[1]] + c2y_yr[sub[2]] + 0x108000) >> 16;
				*db = y; // w/o colors
			}
		}
	}
	else if (subtype == MEDIASUBTYPE_P010 || subtype == MEDIASUBTYPE_P016)
	{
		// Y plane is 16 bits
		WORD* dstY = reinterpret_cast<WORD*>(d);
		WORD* dstYEnd = dstY + w; // What units is w given in?

		for (; dstY < dstYEnd; dstY++, sub += 4)
		{
			if (sub[3] < 0xff)
			{
				// Look up table generates a 32-bit luminance value which is then scaled to 16 bits.
				int y = (c2y_yb[sub[0]] + c2y_yg[sub[1]] + c2y_yr[sub[2]] + 0x108000) >> 16;

				// Do I need to perform any scaling as per SMPTE 274M?
				*dstY = y;
			}
		}
	}
	else if (subtype == MEDIASUBTYPE_YUY2) {
		WORD* ds = (WORD*)d;
		WORD* dstend = ds + w;

		for (; ds < dstend; sub += 4, ds++) {
			if (sub[3] < 0xff) {
				int y = (c2y_yb[sub[0]] + c2y_yg[sub[1]] + c2y_yr[sub[2]] + 0x108000) >> 16;
				*ds = 0x8000 | y; // w/o colors
			}
		}
	}
	else if (subtype == MEDIASUBTYPE_RGB555) {
		WORD* ds = (WORD*)d;
		WORD* dstend = ds + w;

		for (; ds < dstend; sub += 4, ds++) {
			if (sub[3] < 0xff) {
				*ds = ((*((DWORD*)sub) >> 9) & 0x7c00) | ((*((DWORD*)sub) >> 6) & 0x03e0) | ((*((DWORD*)sub) >> 3) & 0x001f);
			}
		}
	}
	else if (subtype == MEDIASUBTYPE_RGB565) {
		WORD* ds = (WORD*)d;
		WORD* dstend = ds + w;

		for (; ds < dstend; sub += 4, ds++) {
			if (sub[3] < 0xff) {
				*ds = ((*((DWORD*)sub) >> 8) & 0xf800) | ((*((DWORD*)sub) >> 5) & 0x07e0) | ((*((DWORD*)sub) >> 3) & 0x001f);
			}
		}
	}
	else if (subtype == MEDIASUBTYPE_RGB24) {
		BYTE* dt = (BYTE*)d;
		BYTE* dstend = dt + w * 3;

		for (; dt < dstend; sub += 4, dt += 3) {
			if (sub[3] < 0xff) {
				dt[0] = sub[0];
				dt[1] = sub[1];
				dt[2] = sub[2];
			}
		}
	}
	else if (subtype == MEDIASUBTYPE_RGB32 || subtype == MEDIASUBTYPE_ARGB32) {
		DWORD* dstend = d + w;

		for (; d < dstend; sub += 4, d++) {
			if (sub[3] < 0xff) {
				*d = *((DWORD*)sub) & 0xffffff;
			}
		}
	}
}

HRESULT CDirectVobSubFilter::Copy(BYTE* pSub, BYTE* pIn, CSize sub, CSize in, int bpp, const GUID& subtype, DWORD black)
{
	int wIn = in.cx, hIn = in.cy, pitchIn = wIn * bpp >> 3;
	int wSub = sub.cx, hSub = sub.cy, pitchSub = wSub * bpp >> 3;
	bool fScale2x = wIn * 2 <= wSub;

	if (fScale2x) {
		wIn <<= 1, hIn <<= 1;
	}

	int left = ((wSub - wIn) >> 1) & ~1;
	int mid = wIn;
	int right = left + ((wSub - wIn) & 1);

	int dpLeft = left * bpp >> 3;
	int dpMid = mid * bpp >> 3;
	int dpRight = right * bpp >> 3;

	ASSERT(wSub >= wIn);

	{
		int i = 0, j = 0;

		j += (hSub - hIn) >> 1;

		for (; i < j; i++, pSub += pitchSub) {
			memset_u32(pSub, black, dpLeft + dpMid + dpRight);
		}

		j += hIn;

		if (hIn > hSub) {
			pIn += pitchIn * ((hIn - hSub) >> (fScale2x ? 2 : 1));
		}

		if (fScale2x) {
			Scale2x(subtype,
				pSub + dpLeft, pitchSub, pIn, pitchIn,
				in.cx, (std::min(j, hSub) - i) >> 1);

			for (int k = std::min(j, hSub); i < k; i++, pIn += pitchIn, pSub += pitchSub) {
				memset_u32(pSub, black, dpLeft);
				memset_u32(pSub + dpLeft + dpMid, black, dpRight);
			}
		}
		else {
			for (int k = std::min(j, hSub); i < k; i++, pIn += pitchIn, pSub += pitchSub) {
				memset_u32(pSub, black, dpLeft);
				memcpy(pSub + dpLeft, pIn, dpMid);
				memset_u32(pSub + dpLeft + dpMid, black, dpRight);
			}
		}

		j = hSub;

		for (; i < j; i++, pSub += pitchSub) {
			memset_u32(pSub, black, dpLeft + dpMid + dpRight);
		}
	}

	return NOERROR;
}

void CDirectVobSubFilter::PrintMessages(BYTE* pOut)
{
	if (!m_hdc || !m_hbm) {
		return;
	}

	ColorConvInit();

	const GUID& subtype = m_pOutput->CurrentMediaType().subtype;

	BITMAPINFOHEADER bihOut;
	ExtractBIH(&m_pOutput->CurrentMediaType(), &bihOut);

	CString msg, tmp;

	if (m_bOSD) {
		CString input = MediaSubtype2String(m_pInput->CurrentMediaType().subtype);
		if (!input.Left(13).CompareNoCase(L"MEDIASUBTYPE_")) {
			input = input.Mid(13);
		}
		CString output = MediaSubtype2String(m_pOutput->CurrentMediaType().subtype);
		if (!output.Left(13).CompareNoCase(L"MEDIASUBTYPE_")) {
			output = output.Mid(13);
		}

		tmp.Format(L"in: %dx%d %ws\nout: %dx%d %ss\n",
			m_win, m_hout,
			input.GetBuffer(),
			bihOut.biWidth, bihOut.biHeight,
			output);
		msg += tmp;

		tmp.Format(L"real fps: %.3f, current fps: %.3f\nmedia time: %d, subtitle time: %d [ms]\nframe number: %d (calculated)\nrate: %.4f\n",
			m_fps, m_bMediaFPSEnabled ? m_MediaFPS : fabs(m_fps),
			(int)m_tPrev.Millisecs(), (int)(CalcCurrentTime() / 10000),
			(int)(m_tPrev.m_time * m_fps / 10000000),
			m_pInput->CurrentRate());
		msg += tmp;

		DSAutoLock cAutoLock(&m_csQueueLock);

		if (m_pSubPicQueue) {
			int nSubPics = -1;
			REFERENCE_TIME rtNow = -1, rtStart = -1, rtStop = -1;
			m_pSubPicQueue->GetStats(nSubPics, rtNow, rtStart, rtStop);
			tmp.Format(L"queue stats: %I64d - %I64d [ms]\n", rtStart / 10000, rtStop / 10000);
			msg += tmp;

			for (int i = 0; i < nSubPics; i++) {
				m_pSubPicQueue->GetStats(i, rtStart, rtStop);
				tmp.Format(L"%d: %I64d - %I64d [ms]\n", i, rtStart / 10000, rtStop / 10000);
				msg += tmp;
			}

		}
	}

	if (msg.IsEmpty()) {
		return;
	}

	HANDLE hOldBitmap = SelectObject(m_hdc, m_hbm);
	HANDLE hOldFont = SelectObject(m_hdc, m_hfont);

	SetTextColor(m_hdc, 0xffffff);
	SetBkMode(m_hdc, TRANSPARENT);
	SetMapMode(m_hdc, MM_TEXT);

	BITMAP bm;
	GetObjectW(m_hbm, sizeof(BITMAP), &bm);

	CRect r(0, 0, bm.bmWidth, bm.bmHeight);
	DrawTextW(m_hdc, msg, wcslen(msg), &r, DT_CALCRECT | DT_EXTERNALLEADING | DT_NOPREFIX | DT_WORDBREAK);

	r += CPoint(10, 10);
	r &= CRect(0, 0, bm.bmWidth, bm.bmHeight);

	DrawTextW(m_hdc, msg, wcslen(msg), &r, DT_LEFT | DT_TOP | DT_NOPREFIX | DT_WORDBREAK);

	BYTE* pIn = (BYTE*)bm.bmBits;
	int pitchIn = bm.bmWidthBytes;
	int pitchOut = bihOut.biWidth * bihOut.biBitCount >> 3;

	if (subtype == MEDIASUBTYPE_YV12 || subtype == MEDIASUBTYPE_I420 || subtype == MEDIASUBTYPE_IYUV
		|| subtype == MEDIASUBTYPE_NV12) {
		pitchOut = bihOut.biWidth;
	}
	else if (subtype == MEDIASUBTYPE_P010 || subtype == MEDIASUBTYPE_P016) {
		pitchOut = bihOut.biWidth * 2;
	}

	pitchIn = (pitchIn + 3) & ~3;
	pitchOut = (pitchOut + 3) & ~3;

	if (bihOut.biHeight > 0 && bihOut.biCompression <= 3) { // flip if the dst bitmap is flipped rgb (m_hbm is a top-down bitmap, not like the subpictures)
		pOut += pitchOut * (abs(bihOut.biHeight) - 1);
		pitchOut = -pitchOut;
	}

	pIn += pitchIn * r.top;
	pOut += pitchOut * r.top;

	for (int w = std::min((int)r.right, m_win), h = r.Height(); h--; pIn += pitchIn, pOut += pitchOut) {
		BltLineRGB32((DWORD*)pOut, pIn, w, subtype);
		memset_u32(pIn, 0xff000000, r.right * 4);
	}

	SelectObject(m_hdc, hOldBitmap);
	SelectObject(m_hdc, hOldFont);
}


/*removeme*/
bool g_RegOK = true;//false; // doesn't work with the dvd graph builder


class CDirectVobSubFilter;

class CTextInputPin : public CSubtitleInputPin
{
	CDirectVobSubFilter* m_pDVS = nullptr;

public:
	CTextInputPin(CDirectVobSubFilter* pFilter, CCritSec* pLock, CCritSec* pSubLock, HRESULT* phr)
		: CSubtitleInputPin(pFilter, pLock, pSubLock, phr)
		, m_pDVS(pFilter)
	{
	}
protected:
	void AddSubStream(ISubStream* pSubStream)
	{
		m_pDVS->AddSubStream(pSubStream);
	}

	void RemoveSubStream(ISubStream* pSubStream)
	{
		m_pDVS->RemoveSubStream(pSubStream);
	}

	void InvalidateSubtitle(REFERENCE_TIME rtStart, ISubStream* pSubStream)
	{
		m_pDVS->InvalidateSubtitle(rtStart, (DWORD_PTR)pSubStream);
	}
};


LPCWSTR MediaSubtype2String(const GUID& subtype)
{
	if (subtype == MEDIASUBTYPE_P010) { return L"P010"; }
	if (subtype == MEDIASUBTYPE_P016) { return L"P016"; }
	if (subtype == MEDIASUBTYPE_NV12) { return L"NV12"; }
	if (subtype == MEDIASUBTYPE_YV12) { return L"YV12"; }
	if (subtype == MEDIASUBTYPE_YUY2) { return L"YUY2"; }
	if (subtype == MEDIASUBTYPE_I420) { return L"I420"; }
	if (subtype == MEDIASUBTYPE_IYUV) { return L"IYUV"; }
	if (subtype == MEDIASUBTYPE_ARGB32) { return L"ARGB32"; }
	if (subtype == MEDIASUBTYPE_RGB32) { return L"RGB32"; }
	if (subtype == MEDIASUBTYPE_RGB24) { return L"RGB24"; }
	if (subtype == MEDIASUBTYPE_RGB565) { return L"RGB565"; }
	if (subtype == MEDIASUBTYPE_RGB555) { return L"RGB555"; }

	return L"unknown";
}

////////////////////////////////////////////////////////////////////////////
//
// Constructor
//

CDirectVobSubFilter::CDirectVobSubFilter(LPUNKNOWN punk, HRESULT* phr, const GUID& clsid)
	: CBaseVideoFilter(L"CDirectVobSubFilter", punk, phr, clsid)
	, m_nSubtitleId((DWORD_PTR)-1)
	, m_bMSMpeg4Fix(false)
	, m_fps(25)
	, m_hEvtTransform(nullptr)
{
	m_hdc = 0;
	m_hbm = 0;
	m_hfont = 0;

	{
		LOGFONT lf;
		memset(&lf, 0, sizeof(lf));
		lf.lfCharSet = DEFAULT_CHARSET;
		lf.lfOutPrecision = OUT_CHARACTER_PRECIS;
		lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
		lf.lfQuality = ANTIALIASED_QUALITY;
		HDC hdc = GetDC(nullptr);
		lf.lfHeight = -MulDiv(10, GetDeviceCaps(hdc, LOGPIXELSY), 72);
		ReleaseDC(nullptr, hdc);
		lf.lfWeight = FW_BOLD;
		wcscpy_s(lf.lfFaceName, WXGetSubtitleFontName().c_str());
		m_hfont = CreateFontIndirectW(&lf);
	}

	m_bLoading = true;

	HRESULT hr = S_OK;
	m_pTextInputs.push_back(new CTextInputPin(this, m_pLock, &m_csSubLock, &hr));
	ASSERT(SUCCEEDED(hr));

	CAMThread::Create();
	m_frd.EndThreadEvent.Create(0, FALSE, FALSE, 0);
	m_frd.RefreshEvent.Create(0, FALSE, FALSE, 0);

	memset(&m_CurrentVIH2, 0, sizeof(VIDEOINFOHEADER2));

	m_hEvtTransform = CreateEventW(nullptr, FALSE, TRUE, nullptr);

	VDCPUTest();
}

CDirectVobSubFilter::~CDirectVobSubFilter()
{
	DSAutoLock cAutoLock(&m_csQueueLock);
	if (m_pSubPicQueue) {
		m_pSubPicQueue->Invalidate();
	}
	m_pSubPicQueue.Release();

	if (m_hfont) {
		DeleteObject(m_hfont);
		m_hfont = 0;
	}
	if (m_hbm) {
		DeleteObject(m_hbm);
		m_hbm = 0;
	}
	if (m_hdc) {
		DeleteObject(m_hdc);
		m_hdc = 0;
	}

	for (auto& pTextInput : m_pTextInputs) {
		delete pTextInput;
	}

	m_frd.EndThreadEvent.Set();
	CAMThread::Close();

	if (m_hEvtTransform) {
		CloseHandle(m_hEvtTransform);
		m_hEvtTransform = nullptr;
	}
}

STDMETHODIMP CDirectVobSubFilter::NonDelegatingQueryInterface(REFIID riid, void** ppv)
{
	CheckPointer(ppv, E_POINTER);

	return
		QI(IDirectVobSub)
		QI(IDirectVobSub2)
		QI(IDirectVobSub3)
		QI(IAMStreamSelect)
		__super::NonDelegatingQueryInterface(riid, ppv);
}

// CBaseVideoFilter

static inline bool BitBltFromP016ToP016(size_t w, size_t h, BYTE* dstY, BYTE* dstUV, int dstPitch, BYTE* srcY, BYTE* srcUV, int srcPitch)
{
	// Copy Y plane
	for (size_t row = 0; row < h; row++) {
		BYTE* src = srcY + row * srcPitch;
		BYTE* dst = dstY + row * dstPitch;

		memcpy(dst, src, dstPitch);
	}

	// Copy UV plane. UV plane is half height.
	for (size_t row = 0; row < h / 2; row++) {
		BYTE* src = srcUV + row * srcPitch;
		BYTE* dst = dstUV + row * dstPitch;

		memcpy(dst, src, dstPitch);
	}

	return true;
}

HRESULT CDirectVobSubFilter::CopyBuffer(BYTE* pOut, BYTE* pIn, int w, int h, int pitchIn, const GUID& subtype, bool fInterlaced)
{
	int abs_h = abs(h);
	BYTE* pInYUV[3] = { pIn, pIn + pitchIn * abs_h, pIn + pitchIn * abs_h + (pitchIn / 2) * (abs_h / 2) };

	BITMAPINFOHEADER bihOut;
	ExtractBIH(&m_pOutput->CurrentMediaType(), &bihOut);

	int pitchOut = 0;

	if (bihOut.biCompression == BI_RGB || bihOut.biCompression == BI_BITFIELDS) {
		pitchOut = bihOut.biWidth * bihOut.biBitCount >> 3;

		if (bihOut.biHeight > 0) {
			pOut += pitchOut * (h - 1);
			pitchOut = -pitchOut;
			if (h < 0) {
				h = -h;
			}
		}
	}

	if (h < 0) {
		h = -h;
		pInYUV[0] += pitchIn * (h - 1);
		if (subtype == MEDIASUBTYPE_I420 || subtype == MEDIASUBTYPE_IYUV || subtype == MEDIASUBTYPE_YV12) {
			pInYUV[1] += (pitchIn >> 1) * ((h >> 1) - 1);
			pInYUV[2] += (pitchIn >> 1) * ((h >> 1) - 1);
		}
		else if (subtype == MEDIASUBTYPE_P010 || subtype == MEDIASUBTYPE_P016 || subtype == MEDIASUBTYPE_NV12) {
			pInYUV[1] += pitchIn * ((h >> 1) - 1);
		}
		pitchIn = -pitchIn;
	}

	if (subtype == MEDIASUBTYPE_I420 || subtype == MEDIASUBTYPE_IYUV || subtype == MEDIASUBTYPE_YV12) {
		BYTE* pIn = pInYUV[0];
		BYTE* pInU = pInYUV[1];
		BYTE* pInV = pInYUV[2];

		if (subtype == MEDIASUBTYPE_YV12) {
			std::swap(pInU, pInV);
		}

		BYTE* pOutU = pOut + bihOut.biWidth * h;
		BYTE* pOutV = pOut + bihOut.biWidth * h * 5 / 4;

		if (bihOut.biCompression == FCC('YV12')) {
			std::swap(pOutU, pOutV);
		}

		ASSERT(w <= abs(pitchIn));

		if (bihOut.biCompression == FCC('YUY2')) {
			if (!fInterlaced) {
				BitBltFromI420ToYUY2(w, h, pOut, bihOut.biWidth * 2, pIn, pInU, pInV, pitchIn);
			}
			else {
				BitBltFromI420ToYUY2Interlaced(w, h, pOut, bihOut.biWidth * 2, pIn, pInU, pInV, pitchIn);
			}
		}
		else if (bihOut.biCompression == FCC('I420') || bihOut.biCompression == FCC('IYUV') || bihOut.biCompression == FCC('YV12')) {
			BitBltFromI420ToI420(w, h, pOut, pOutU, pOutV, bihOut.biWidth, pIn, pInU, pInV, pitchIn);
		}
		else if (bihOut.biCompression == FCC('NV12')) {
			BitBltFromI420ToNV12(w, h, pOut, pOutU, pOutV, bihOut.biWidth, pIn, pInU, pInV, pitchIn);
		}
		else if (bihOut.biCompression == BI_RGB || bihOut.biCompression == BI_BITFIELDS) {
			if (!BitBltFromI420ToRGB(w, h, pOut, pitchOut, bihOut.biBitCount, pIn, pInU, pInV, pitchIn)) {
				for (int y = 0; y < h; y++, pOut += pitchOut) {
					memset_u32(pOut, 0, pitchOut);
				}
			}
		}
	}
	else if ((subtype == MEDIASUBTYPE_P010 || subtype == MEDIASUBTYPE_P016)
		&& (bihOut.biCompression == FCC('P010') || bihOut.biCompression == FCC('P016'))) {
		// We currently don't support outputting P010/P016 input to something other than P010/P016
		// P010 and P016 share the same memory layout
		BYTE* pInY = pInYUV[0];
		BYTE* pInUV = pInYUV[1];
		BYTE* pOutUV = pOut + bihOut.biWidth * h * 2; // 2 bytes per pixel
		BitBltFromP016ToP016(w, h, pOut, pOutUV, bihOut.biWidth * 2, pInY, pInUV, pitchIn);
	}
	else if (subtype == MEDIASUBTYPE_NV12 && bihOut.biCompression == FCC('NV12')) {
		// We currently don't support outputting NV12 input to something other than NV12
		BYTE* pInY = pInYUV[0];
		BYTE* pInUV = pInYUV[1];
		BYTE* pOutUV = pOut + bihOut.biWidth * h; // 1 bytes per pixel
		BitBltFromP016ToP016(w, h, pOut, pOutUV, bihOut.biWidth, pInY, pInUV, pitchIn);
	}
	else if (subtype == MEDIASUBTYPE_YUY2) {
		if (bihOut.biCompression == FCC('YUY2')) {
			BitBltFromYUY2ToYUY2(w, h, pOut, bihOut.biWidth * 2, pInYUV[0], pitchIn);
		}
		else if (bihOut.biCompression == BI_RGB || bihOut.biCompression == BI_BITFIELDS) {
			if (!BitBltFromYUY2ToRGB(w, h, pOut, pitchOut, bihOut.biBitCount, pInYUV[0], pitchIn)) {
				for (int y = 0; y < h; y++, pOut += pitchOut) {
					memset_u32(pOut, 0, pitchOut);
				}
			}
		}
	}
	else if (subtype == MEDIASUBTYPE_ARGB32 || subtype == MEDIASUBTYPE_RGB32 || subtype == MEDIASUBTYPE_RGB24 || subtype == MEDIASUBTYPE_RGB565) {
		int sbpp =
			subtype == MEDIASUBTYPE_ARGB32 || subtype == MEDIASUBTYPE_RGB32 ? 32 :
			subtype == MEDIASUBTYPE_RGB24 ? 24 :
			subtype == MEDIASUBTYPE_RGB565 ? 16 : 0;

		if (bihOut.biCompression == FCC('YUY2')) {
			// TODO
			// BitBltFromRGBToYUY2();
		}
		else if (bihOut.biCompression == BI_RGB || bihOut.biCompression == BI_BITFIELDS) {
			if (!BitBltFromRGBToRGB(w, h, pOut, pitchOut, bihOut.biBitCount, pInYUV[0], pitchIn, sbpp)) {
				for (int y = 0; y < h; y++, pOut += pitchOut) {
					memset_u32(pOut, 0, pitchOut);
				}
			}
		}
	}
	else {
		return VFW_E_TYPE_NOT_ACCEPTED;
	}

	return S_OK;
}

void CDirectVobSubFilter::GetOutputFormats(int& nNumber, VIDEO_OUTPUT_FORMATS** ppFormats)
{
	nNumber = m_VideoOutputFormats.size();
	*ppFormats = m_VideoOutputFormats.size() ? m_VideoOutputFormats.data() : nullptr;
}

void CDirectVobSubFilter::GetOutputSize(int& w, int& h, int& arx, int& ary)
{
	CSize s(w, h), os = s;
	AdjustFrameSize(s);
	w = s.cx;
	h = s.cy;

	if (w != os.cx) {
		while (arx < 100) {
			arx *= 10, ary *= 10;
		}
		arx = arx * w / os.cx;
	}

	if (h != os.cy) {
		while (ary < 100) {
			arx *= 10, ary *= 10;
		}
		ary = ary * h / os.cy;
	}
}




//强制刷新
IMediaSample* CDirectVobSubFilter::Redraw() {
	HandleImage(FALSE);
	return &m_outSample;
}

//Graph 链路处理
HRESULT CDirectVobSubFilter::Transform(IMediaSample* pInSample) {

	if (!Open()) {
		//没有加载字幕文件
		HRESULT hr = m_pOutput->Deliver(pInSample);//推送到Render
		return hr;
	}


	m_inSample.Clone(pInSample); //保存图像用来处理
	m_outSample.Clone(pInSample);//保存图像用来输出
	HandleImage(TRUE);
	return S_OK;
}

HRESULT CDirectVobSubFilter::HandleImage(BOOL bRender)
{
	if (m_inSample.m_pBuffer.GetBuffer() == nullptr) {
		return S_FALSE;
	}

	if (bRender)
		EXECUTE_ASSERT(WAIT_OBJECT_0 == WaitForSingleObject(m_hEvtTransform, INFINITE));

	REFERENCE_TIME rtStart, rtStop;
	HRESULT hr = m_inSample.GetTime(&rtStart, &rtStop);
	if (FAILED(hr)) {
		rtStart = rtStop = INVALID_TIME;
	}
	else if (hr == VFW_S_NO_STOP_TIME || rtStop - 1 <= rtStart) {
		rtStop = INVALID_TIME;
	}

	const double dRate = m_pInput->CurrentRate();
	if (rtStart != INVALID_TIME) {
		m_tPrev = m_pInput->CurrentStartTime() + rtStart * (m_bExternalSubtitle ? dRate : 1);
	}

	if (rtStop != INVALID_TIME) {
		REFERENCE_TIME rtAvgTimePerFrame = rtStop - rtStart;
		if (CComQIPtr<ISubClock2> pSC2 = m_pSubClock.p) {
			REFERENCE_TIME rt;
			if (S_OK == pSC2->GetAvgTimePerFrame(&rt)) {
				rtAvgTimePerFrame = rt;
			}
		}

		m_fps = 10000000.0 / rtAvgTimePerFrame / dRate;
	}

	if (bRender) {
		DSAutoLock cAutoLock(&m_csQueueLock);
		if (m_pSubPicQueue) {
			m_pSubPicQueue->SetTime(CalcCurrentTime());
			m_pSubPicQueue->SetFPS(m_fps);
		}
	}
	else {
		if (m_pSubPicQueue) {
			m_pSubPicQueue->SetTime(CalcCurrentTime());
			m_pSubPicQueue->SetFPS(m_fps);
		}
	}

	BYTE* pDataIn = nullptr;
	if (FAILED(m_inSample.GetPointer(&pDataIn)) || !pDataIn) {
		if (bRender)
			SetEvent(m_hEvtTransform);
		return S_FALSE;
	}

	const CMediaType& mt = m_pInput->CurrentMediaType();

	BITMAPINFOHEADER bihIn;
	ExtractBIH(&mt, &bihIn);

	bool fYV12 = (mt.subtype == MEDIASUBTYPE_YV12 || mt.subtype == MEDIASUBTYPE_I420 || mt.subtype == MEDIASUBTYPE_IYUV);
	int bpp = fYV12 ? 8 : bihIn.biBitCount;
	DWORD black = fYV12 ? 0x10101010 : (bihIn.biCompression == FCC('YUY2')) ? 0x80108010 : 0;

	if (mt.subtype == MEDIASUBTYPE_P010 || mt.subtype == MEDIASUBTYPE_P016) {
		bpp = 16;
		black = 0x10001000;
	}
	else if (mt.subtype == MEDIASUBTYPE_NV12) {
		bpp = 8;
		black = 0x10101010;
	}
	CSize sub(m_wout, m_hout);
	CSize in(bihIn.biWidth, bihIn.biHeight);

	if (FAILED(Copy(m_pTempPicBuff.get(), pDataIn, sub, in, bpp, mt.subtype, black))) {
		if (bRender)
			SetEvent(m_hEvtTransform);
		return E_FAIL;
	}

	if (fYV12) {
		BYTE* pSubV = m_pTempPicBuff.get() + (sub.cx * bpp >> 3) * sub.cy;
		BYTE* pInV = pDataIn + (in.cx * bpp >> 3) * in.cy;
		sub.cx >>= 1;
		sub.cy >>= 1;
		in.cx >>= 1;
		in.cy >>= 1;
		BYTE* pSubU = pSubV + (sub.cx * bpp >> 3) * sub.cy;
		BYTE* pInU = pInV + (in.cx * bpp >> 3) * in.cy;
		if (FAILED(Copy(pSubV, pInV, sub, in, bpp, mt.subtype, 0x80808080))) {
			if (bRender)
				SetEvent(m_hEvtTransform);
			return E_FAIL;
		}
		if (FAILED(Copy(pSubU, pInU, sub, in, bpp, mt.subtype, 0x80808080))) {
			if (bRender)
				SetEvent(m_hEvtTransform);
			return E_FAIL;
		}
	}

	if (mt.subtype == MEDIASUBTYPE_P010 || mt.subtype == MEDIASUBTYPE_P016 || mt.subtype == MEDIASUBTYPE_NV12) {
		BYTE* pSubUV = m_pTempPicBuff.get() + (sub.cx * bpp >> 3) * sub.cy;
		BYTE* pInUV = pDataIn + (in.cx * bpp >> 3) * in.cy;
		sub.cy >>= 1;
		in.cy >>= 1;
		if (FAILED(Copy(pSubUV, pInUV, sub, in, bpp, mt.subtype, mt.subtype == MEDIASUBTYPE_NV12 ? 0x80808080 : 0x80008000))) {
			if (bRender)
				SetEvent(m_hEvtTransform);
			return E_FAIL;
		}
	}

	DXVA2_ExtendedFormat dxvaExtFormat = { 0 };
	if (mt.formattype == FORMAT_VideoInfo2) {
		VIDEOINFOHEADER2* vih2 = (VIDEOINFOHEADER2*)mt.Format();
		dxvaExtFormat.value = vih2->dwControlFlags;
	}

	SubPicDesc spd = m_spd;
	CComPtr<IMediaSample> pOut;
	BYTE* pDataOut = nullptr;

	if (bRender) {
		if (FAILED(hr = GetDeliveryBuffer(spd.w, spd.h, &pOut, 0, &dxvaExtFormat))
			|| FAILED(hr = pOut->GetPointer(&pDataOut))) {
			if (bRender)
				SetEvent(m_hEvtTransform);
			return hr;
		}
	}
	else {
		pOut = &m_outSample;
		pOut->GetPointer(&pDataOut);
		if (pDataOut == nullptr) {
			return E_FAIL;
		}
	}


	if (rtStop == INVALID_TIME) {
		if (m_fps > 0.0) {
			REFERENCE_TIME rtAvgTimePerFrame = 10000000.0 / m_fps;
			rtStop = rtStart + rtAvgTimePerFrame;
		}
		else {
			rtStop = rtStart + 1;
		}
	}
	pOut->SetTime(&rtStart, &rtStop);
	pOut->SetMediaTime(nullptr, nullptr);

	pOut->SetDiscontinuity(m_inSample.IsDiscontinuity() == S_OK);
	pOut->SetSyncPoint(m_inSample.IsSyncPoint() == S_OK);
	pOut->SetPreroll(m_inSample.IsPreroll() == S_OK);

	BITMAPINFOHEADER bihOut;
	ExtractBIH(&m_pOutput->CurrentMediaType(), &bihOut);

	bool fInputFlipped = bihIn.biHeight >= 0 && bihIn.biCompression <= 3;
	bool fOutputFlipped = bihOut.biHeight >= 0 && bihOut.biCompression <= 3;

	bool fFlip = fInputFlipped != fOutputFlipped;
	if (m_bFlipPicture) {
		fFlip = !fFlip;
	}
	if (m_bMSMpeg4Fix) {
		fFlip = !fFlip;
	}

	bool fFlipSub = fOutputFlipped;
	if (m_bFlipSubtitles) {
		fFlipSub = !fFlipSub;
	}

	if (bRender) {
		DSAutoLock cAutoLock(&m_csQueueLock);

		if (m_pSubPicQueue) {
			CComPtr<ISubPic> pSubPic;
			if ((m_pSubPicQueue->LookupSubPic(CalcCurrentTime(), pSubPic)) && pSubPic) {
				CRect r;
				pSubPic->GetDirtyRect(r);

				if (fFlip ^ fFlipSub) {
					spd.h = -spd.h;
				}

				pSubPic->AlphaBlt(r, r, &spd);
			}
		}
	}
	else {
		if (m_pSubPicQueue) {
			CComPtr<ISubPic> pSubPic;
			if ((m_pSubPicQueue->LookupSubPic(CalcCurrentTime(), pSubPic)) && pSubPic) {
				CRect r;
				pSubPic->GetDirtyRect(r);

				if (fFlip ^ fFlipSub) {
					spd.h = -spd.h;
				}

				pSubPic->AlphaBlt(r, r, &spd);
			}
		}
	}

	CopyBuffer(pDataOut, spd.bits, spd.w, abs(spd.h) * (fFlip ? -1 : 1), spd.pitch, mt.subtype);

	{
		// copy dwTypeSpecificFlags from input IMediaSample
		if (CComQIPtr<IMediaSample2> pMS2in = &m_inSample) {
			AM_SAMPLE2_PROPERTIES propsIn;
			if (SUCCEEDED(pMS2in->GetProperties(sizeof(propsIn), (BYTE*)&propsIn))) {
				if (CComQIPtr<IMediaSample2> pMS2out = pOut.p) {
					AM_SAMPLE2_PROPERTIES propsOut;
					if (SUCCEEDED(pMS2out->GetProperties(sizeof(propsOut), (BYTE*)&propsOut))) {
						propsOut.dwTypeSpecificFlags = propsIn.dwTypeSpecificFlags;
						pMS2out->SetProperties(sizeof(propsOut), (BYTE*)&propsOut);
					}
				}
			}
		}
	}

	if (bRender)
		SetEvent(m_hEvtTransform);
	hr = S_OK;
	if (bRender)
		hr = m_pOutput->Deliver(pOut);//推送到Render
	return hr;
}

// CBaseFilter

CBasePin* CDirectVobSubFilter::GetPin(int n)
{
	int NN = __super::GetPinCount();
	if (n < __super::GetPinCount()) {
		return __super::GetPin(n);
	}

	n -= __super::GetPinCount();

	if (n >= 0 && n < (int)m_pTextInputs.size()) {
		return m_pTextInputs[n];
	}

	n -= m_pTextInputs.size();

	return nullptr;
}

int CDirectVobSubFilter::GetPinCount()
{
	return __super::GetPinCount() + m_pTextInputs.size();
}

HRESULT CDirectVobSubFilter::JoinFilterGraph(IFilterGraph* pGraph, LPCWSTR pName)
{
	return __super::JoinFilterGraph(pGraph, pName);
}

STDMETHODIMP CDirectVobSubFilter::QueryFilterInfo(FILTER_INFO* pInfo)
{
	CheckPointer(pInfo, E_POINTER);
	ValidateReadWritePtr(pInfo, sizeof(FILTER_INFO));

	if (!get_Forced()) {
		return __super::QueryFilterInfo(pInfo);
	}

	wcscpy_s(pInfo->achName, L"DirectVobSub (forced auto-loading version)");
	pInfo->pGraph = m_pGraph;
	if (m_pGraph) {
		m_pGraph->AddRef();
	}

	return S_OK;
}

// CTransformFilter

HRESULT CDirectVobSubFilter::GetMediaType(int iPosition, CMediaType* pmt)
{
	VIDEO_OUTPUT_FORMATS* fmts;
	int                   nFormatCount;

	if (m_pInput->IsConnected() == FALSE) {
		return E_UNEXPECTED;
	}

	GetOutputFormats(nFormatCount, &fmts);
	if (iPosition < 0) {
		return E_INVALIDARG;
	}
	if (iPosition >= nFormatCount) {
		return VFW_S_NO_MORE_ITEMS;
	}

	pmt->majortype = MEDIATYPE_Video;
	pmt->subtype = *fmts[iPosition].subtype;

	int w = m_win;
	int h = m_hin;
	int arx = m_arxin;
	int ary = m_aryin;
	GetOutputSize(w, h, arx, ary);

	m_wout = m_win;
	m_hout = m_hin;
	m_arxout = m_arxin;
	m_aryout = m_aryin;


	BITMAPINFOHEADER bihOut = { 0 };
	bihOut.biSize = sizeof(bihOut);
	bihOut.biWidth = w;
	bihOut.biHeight = h;
	bihOut.biPlanes = 1; // this value must be set to 1
	bihOut.biBitCount = fmts[iPosition].biBitCount;
	bihOut.biCompression = fmts[iPosition].biCompression;
	bihOut.biSizeImage = DIBSIZE(bihOut);

	pmt->formattype = FORMAT_VideoInfo2;
	VIDEOINFOHEADER2* vih2 = (VIDEOINFOHEADER2*)pmt->AllocFormatBuffer(sizeof(VIDEOINFOHEADER2));
	memset(vih2, 0, sizeof(VIDEOINFOHEADER2));
	vih2->bmiHeader = bihOut;
	vih2->dwPictAspectRatioX = arx;
	vih2->dwPictAspectRatioY = ary;
	if (IsVideoInterlaced()) {
		vih2->dwInterlaceFlags = AMINTERLACE_IsInterlaced | AMINTERLACE_DisplayModeBobOrWeave;
	}

	if (m_dxvaExtFormat.value && pmt->subtype != MEDIASUBTYPE_RGB32 && pmt->subtype != MEDIASUBTYPE_RGB48) {
		vih2->dwControlFlags = m_dxvaExtFormat.value;
	}

	const CMediaType& mtInput = m_pInput->CurrentMediaType();

	// these fields have the same field offset in all four structs
	((VIDEOINFOHEADER*)pmt->Format())->AvgTimePerFrame = ((VIDEOINFOHEADER*)mtInput.Format())->AvgTimePerFrame;
	((VIDEOINFOHEADER*)pmt->Format())->dwBitRate = ((VIDEOINFOHEADER*)mtInput.Format())->dwBitRate;
	((VIDEOINFOHEADER*)pmt->Format())->dwBitErrorRate = ((VIDEOINFOHEADER*)mtInput.Format())->dwBitErrorRate;

	pmt->SetSampleSize(bihOut.biSizeImage);

	return S_OK;
}

HRESULT CDirectVobSubFilter::SetMediaType(PIN_DIRECTION dir, const CMediaType* pmt)
{
	HRESULT hr = __super::SetMediaType(dir, pmt);
	if (FAILED(hr)) {
		return hr;
	}

	if (dir == PINDIR_INPUT) {
		DSAutoLock cAutoLock(&m_csReceive);

		REFERENCE_TIME atpf =
			pmt->formattype == FORMAT_VideoInfo ? ((VIDEOINFOHEADER*)pmt->Format())->AvgTimePerFrame :
			pmt->formattype == FORMAT_VideoInfo2 ? ((VIDEOINFOHEADER2*)pmt->Format())->AvgTimePerFrame :
			0;

		m_fps = atpf ? 10000000.0 / atpf : 25;

		if (pmt->formattype == FORMAT_VideoInfo2) {
			m_CurrentVIH2 = *(VIDEOINFOHEADER2*)pmt->Format();
		}

		InitSubPicQueue();

		{
			m_VideoOutputFormats.clear();

			IPin* pPin = m_pInput->GetConnected();
			std::list<VIDEO_OUTPUT_FORMATS> fmts;

			BeginEnumMediaTypes(pPin, pEMT, pmt) {
				for (const auto& VSFilterFormat : VSFilterDefaultFormats) {
					if (pmt->subtype == *VSFilterFormat.subtype && !Contains(fmts, VSFilterFormat)) {
						fmts.push_back(VSFilterFormat);
					}
				}
			}
			EndEnumMediaTypes(pmt)

				for (const auto& VSFilterFormat : VSFilterDefaultFormats) {
					if (!Contains(fmts, VSFilterFormat)) {
						fmts.push_back(VSFilterFormat);
					}
				}

			m_VideoOutputFormats.reserve(fmts.size());

			for (const auto& fmt : fmts) {
				m_VideoOutputFormats.push_back(fmt);
			}
		}
	}
	else if (dir == PINDIR_OUTPUT) {

	}

	return hr;
}

HRESULT CDirectVobSubFilter::CompleteConnect(PIN_DIRECTION dir, IPin* pReceivePin)
{
	bool reconnected = false;
	if (dir == PINDIR_INPUT) {
		CComPtr<IBaseFilter> pFilter;

		// needed when we have a decoder with a version number of 3.x
		if (SUCCEEDED(m_pGraph->FindFilterByName(L"DivX MPEG-4 DVD Video Decompressor ", &pFilter))
			&& FileVersion::GetVer(L"divx_c32.ax").major <= 4
			|| SUCCEEDED(m_pGraph->FindFilterByName(L"Microcrap MPEG-4 Video Decompressor", &pFilter))
			|| SUCCEEDED(m_pGraph->FindFilterByName(L"Microsoft MPEG-4 Video Decompressor", &pFilter))
			&& FileVersion::GetVer(L"mpg4ds32.ax").major <= 3) {
			m_bMSMpeg4Fix = true;
		}
	}
	else if (dir == PINDIR_OUTPUT) {
		const CMediaType* mtIn = &m_pInput->CurrentMediaType();
		const CMediaType* mtOut = &m_pOutput->CurrentMediaType();
		CMediaType desiredMt;

		bool can_reconnect = false;
		bool can_transform = SUCCEEDED(DoCheckTransform(mtIn, mtOut, true));
		if (mtIn->subtype != mtOut->subtype) {

			VIDEO_OUTPUT_FORMATS* fmts;
			int						nFormatCount, iPosition;
			GetOutputFormats(nFormatCount, &fmts);
			for (int iPosition = 0; iPosition < nFormatCount; iPosition++) {
				if (mtOut->subtype == *fmts[iPosition].subtype) {
					if (GetMediaType(iPosition, &desiredMt) != S_OK) {
						break;
					}

					if (SUCCEEDED(DoCheckTransform(&desiredMt, mtOut, true)) && SUCCEEDED(m_pInput->GetConnected()->QueryAccept(&desiredMt))) {
						can_reconnect = true;
						break;
					}
				}
			}

			if (!can_reconnect && !can_transform) {
				iPosition = 0;
				for (;;) {
					if (GetMediaType(iPosition, &desiredMt) != S_OK) {
						break;
					}
					iPosition++;

					if (SUCCEEDED(DoCheckTransform(&desiredMt, mtOut, true)) && SUCCEEDED(m_pInput->GetConnected()->QueryAccept(&desiredMt))) {
						can_reconnect = true;
						break;
					}
				}
			}
		}

		if (can_reconnect) {
			if (SUCCEEDED(ReconnectPin(m_pInput, &desiredMt))) {
				reconnected = true;
			}
		}
		else if (!can_transform) {
			if (m_pInput->IsConnected()) {
				m_pInput->GetConnected()->Disconnect();
				m_pInput->Disconnect();
			} if (m_pOutput->IsConnected()) {
				m_pOutput->GetConnected()->Disconnect();
				m_pOutput->Disconnect();
			}
			return VFW_E_TYPE_NOT_ACCEPTED;
		}
	}

	if (!reconnected && m_pOutput->IsConnected()) {
		// HACK: triggers CBaseVideoFilter::SetMediaType to adjust m_w/m_h/.. and InitSubPicQueue() to realloc buffers
		m_pInput->SetMediaType(&m_pInput->CurrentMediaType());
	}

	return __super::CompleteConnect(dir, pReceivePin);
}

HRESULT CDirectVobSubFilter::BreakConnect(PIN_DIRECTION dir)
{
	if (dir == PINDIR_INPUT) {
		/*
		if (m_pOutput->IsConnected()) {
			m_pOutput->GetConnected()->Disconnect();
			m_pOutput->Disconnect();
		}
		*/
	}
	else if (dir == PINDIR_OUTPUT) {
		// not really needed, but may free up a little memory
		DSAutoLock cAutoLock(&m_csQueueLock);
		m_pSubPicQueue.Release();
	}

	return __super::BreakConnect(dir);
}

HRESULT CDirectVobSubFilter::StartStreaming()
{
	m_bLoading = false;
	InitSubPicQueue();
	put_MediaFPS(m_bMediaFPSEnabled, m_MediaFPS);
	return __super::StartStreaming();
}

HRESULT CDirectVobSubFilter::StopStreaming()
{
	InvalidateSubtitle();

	return __super::StopStreaming();
}

HRESULT CDirectVobSubFilter::NewSegment(REFERENCE_TIME tStart, REFERENCE_TIME tStop, double dRate)
{
	m_tPrev = tStart;
	return __super::NewSegment(tStart, tStop, dRate);
}

HRESULT CDirectVobSubFilter::CheckInputType(const CMediaType* mtIn)
{
	BITMAPINFOHEADER bih;
	ExtractBIH(mtIn, &bih);

	CComPtr<IBaseFilter> pFilter;

	return mtIn->majortype == MEDIATYPE_Video
		&& (mtIn->subtype == MEDIASUBTYPE_P016
			|| mtIn->subtype == MEDIASUBTYPE_P010
			|| mtIn->subtype == MEDIASUBTYPE_NV12
			|| mtIn->subtype == MEDIASUBTYPE_YV12
			|| mtIn->subtype == MEDIASUBTYPE_I420
			|| (mtIn->subtype == MEDIASUBTYPE_IYUV && FAILED(m_pGraph->FindFilterByName(L"Lentoid HEVC Decoder", &pFilter)))
			|| mtIn->subtype == MEDIASUBTYPE_YUY2
			|| mtIn->subtype == MEDIASUBTYPE_ARGB32
			|| mtIn->subtype == MEDIASUBTYPE_RGB32
			|| mtIn->subtype == MEDIASUBTYPE_RGB24
			|| mtIn->subtype == MEDIASUBTYPE_RGB565)
		&& (mtIn->formattype == FORMAT_VideoInfo
			|| mtIn->formattype == FORMAT_VideoInfo2)
		&& bih.biHeight > 0
		? S_OK
		: VFW_E_TYPE_NOT_ACCEPTED;
}

HRESULT CDirectVobSubFilter::CheckOutputType(const CMediaType& mtOut)
{
	int wout = 0, hout = 0, arxout = 0, aryout = 0;
	return ExtractDim(&mtOut, wout, hout, arxout, aryout)
		&& m_hin == abs((int)hout)
		&& mtOut.subtype != MEDIASUBTYPE_ARGB32
		? S_OK
		: VFW_E_TYPE_NOT_ACCEPTED;
}

HRESULT CDirectVobSubFilter::CheckTransform(const CMediaType* mtIn, const CMediaType* mtOut)
{
	return DoCheckTransform(mtIn, mtOut, false);
}

HRESULT CDirectVobSubFilter::DoCheckTransform(const CMediaType* mtIn, const CMediaType* mtOut, bool checkReconnection)
{
	if (FAILED(CheckInputType(mtIn)) || mtOut->majortype != MEDIATYPE_Video) {
		return VFW_E_TYPE_NOT_ACCEPTED;
	}

	if (mtIn->majortype == MEDIATYPE_Video
		&& (mtIn->subtype == MEDIASUBTYPE_P016 || mtIn->subtype == MEDIASUBTYPE_P010)) {
		if (mtOut->subtype != mtIn->subtype && checkReconnection) {
			return VFW_E_TYPE_NOT_ACCEPTED;
		}
	}
	else if (mtIn->majortype == MEDIATYPE_Video
		&& (mtIn->subtype == MEDIASUBTYPE_YV12
			|| mtIn->subtype == MEDIASUBTYPE_I420
			|| mtIn->subtype == MEDIASUBTYPE_IYUV)) {
		if (mtOut->subtype != MEDIASUBTYPE_YV12
			&& mtOut->subtype != MEDIASUBTYPE_NV12
			&& mtOut->subtype != MEDIASUBTYPE_I420
			&& mtOut->subtype != MEDIASUBTYPE_IYUV
			&& mtOut->subtype != MEDIASUBTYPE_YUY2
			&& mtOut->subtype != MEDIASUBTYPE_ARGB32
			&& mtOut->subtype != MEDIASUBTYPE_RGB32
			&& mtOut->subtype != MEDIASUBTYPE_RGB24
			&& mtOut->subtype != MEDIASUBTYPE_RGB565) {
			return VFW_E_TYPE_NOT_ACCEPTED;
		}
	}
	else if (mtOut->majortype == MEDIATYPE_Video
		&& (mtOut->subtype == MEDIASUBTYPE_P016 || mtOut->subtype == MEDIASUBTYPE_P010 || mtOut->subtype == MEDIASUBTYPE_NV12)) {
		if (mtOut->subtype != mtIn->subtype) {
			return VFW_E_TYPE_NOT_ACCEPTED;
		}
	}
	else if (mtIn->majortype == MEDIATYPE_Video
		&& (mtIn->subtype == MEDIASUBTYPE_YUY2)) {
		if (mtOut->subtype != MEDIASUBTYPE_YUY2
			&& mtOut->subtype != MEDIASUBTYPE_ARGB32
			&& mtOut->subtype != MEDIASUBTYPE_RGB32
			&& mtOut->subtype != MEDIASUBTYPE_RGB24
			&& mtOut->subtype != MEDIASUBTYPE_RGB565) {
			return VFW_E_TYPE_NOT_ACCEPTED;
		}
	}
	else if (mtIn->majortype == MEDIATYPE_Video
		&& (mtIn->subtype == MEDIASUBTYPE_ARGB32
			|| mtIn->subtype == MEDIASUBTYPE_RGB32
			|| mtIn->subtype == MEDIASUBTYPE_RGB24
			|| mtIn->subtype == MEDIASUBTYPE_RGB565)) {
		if (mtOut->subtype != MEDIASUBTYPE_ARGB32
			&& mtOut->subtype != MEDIASUBTYPE_RGB32
			&& mtOut->subtype != MEDIASUBTYPE_RGB24
			&& mtOut->subtype != MEDIASUBTYPE_RGB565) {
			return VFW_E_TYPE_NOT_ACCEPTED;
		}
	}

	return S_OK;
}

//

REFERENCE_TIME CDirectVobSubFilter::CalcCurrentTime()
{
	REFERENCE_TIME rt = m_pSubClock ? m_pSubClock->GetTime() : m_tPrev.GetUnits();
	return (rt - 10000i64 * m_SubtitleDelay) * m_SubtitleSpeedMul / m_SubtitleSpeedDiv; // no, it won't overflow if we use normal parameters (__int64 is enough for about 2000 hours if we multiply it by the max: 65536 as m_SubtitleSpeedMul)
}

void CDirectVobSubFilter::InitSubPicQueue()
{
	EXECUTE_ASSERT(WAIT_OBJECT_0 == WaitForSingleObject(m_hEvtTransform, INFINITE));

	DSAutoLock cAutoLock(&m_csQueueLock);

	if(m_pSubPicQueue)
		m_pSubPicQueue.Release();

	const GUID& subtype = m_pInput->CurrentMediaType().subtype;

	BITMAPINFOHEADER bihIn;
	ExtractBIH(&m_pInput->CurrentMediaType(), &bihIn);

	m_spd.type = -1;
	if (subtype == MEDIASUBTYPE_YV12) {
		m_spd.type = MSP_YV12;
	}
	else if (subtype == MEDIASUBTYPE_P010) {
		m_spd.type = MSP_P010;
	}
	else if (subtype == MEDIASUBTYPE_P016) {
		m_spd.type = MSP_P016;
	}
	else if (subtype == MEDIASUBTYPE_NV12) {
		m_spd.type = MSP_NV12;
	}
	else if (subtype == MEDIASUBTYPE_I420 || subtype == MEDIASUBTYPE_IYUV) {
		m_spd.type = MSP_IYUV;
	}
	else if (subtype == MEDIASUBTYPE_YUY2) {
		m_spd.type = MSP_YUY2;
	}
	else if (subtype == MEDIASUBTYPE_RGB32) {
		m_spd.type = MSP_RGB32;
	}
	else if (subtype == MEDIASUBTYPE_RGB24) {
		m_spd.type = MSP_RGB24;
	}
	else if (subtype == MEDIASUBTYPE_RGB565) {
		m_spd.type = MSP_RGB16;
	}
	else if (subtype == MEDIASUBTYPE_RGB555) {
		m_spd.type = MSP_RGB15;
	}
	m_spd.w = m_wout;
	m_spd.h = m_hout;
	m_spd.bpp = (m_spd.type == MSP_YV12 || m_spd.type == MSP_IYUV || m_spd.type == MSP_NV12) ? 8 : bihIn.biBitCount;
	m_spd.bpp = (m_spd.type == MSP_P010 || m_spd.type == MSP_P016) ? 16 : m_spd.bpp;
	m_spd.pitch = m_spd.w * m_spd.bpp >> 3;

	size_t picbufsize;
	if (m_spd.type == MSP_YV12 || m_spd.type == MSP_IYUV || m_spd.type == MSP_NV12) {
		picbufsize = 4 * m_spd.pitch * m_spd.h;
	}
	else if (m_spd.type == MSP_P010 || m_spd.type == MSP_P016) {
		picbufsize = m_spd.pitch * m_spd.h + m_spd.pitch * m_spd.h / 2;
	}
	else {
		picbufsize = m_spd.pitch * m_spd.h;
	}

	m_pTempPicBuff.reset(new BYTE[picbufsize]);
	m_spd.bits = m_pTempPicBuff.get();

	CComPtr<ISubPicAllocator> pSubPicAllocator = new CMemSubPicExAllocator(m_spd.type, CSize(m_wout, m_hout));

	CSize video(bihIn.biWidth, bihIn.biHeight), window = video;
	if (AdjustFrameSize(window)) {
		video += video;
	}

	pSubPicAllocator->SetCurSize(window);
	pSubPicAllocator->SetCurVidRect(CRect(CPoint((window.cx - video.cx) / 2, (window.cy - video.cy) / 2), video));

	HRESULT hr = S_OK;

	m_pSubPicQueue = m_uSubPictToBuffer > 0
		? (ISubPicQueue*)new CSubPicQueue(m_uSubPictToBuffer, !m_bAnimWhenBuffering, m_bAllowDropSubPic, pSubPicAllocator, &hr)
		: (ISubPicQueue*)new CSubPicQueueNoThread(!m_bAnimWhenBuffering, pSubPicAllocator, &hr);

	if (FAILED(hr)) {
		m_pSubPicQueue.Release();
	}

	UpdateSubtitle(false);

	if (m_hbm) {
		DeleteObject(m_hbm);
		m_hbm = nullptr;
	}
	if (m_hdc) {
		DeleteDC(m_hdc);
		m_hdc = nullptr;
	}

	static struct {
		BITMAPINFOHEADER bih;
		DWORD mask[3];
	} b = { {sizeof(BITMAPINFOHEADER), m_win, -(int)m_hin, 1, 32, BI_BITFIELDS, 0, 0, 0, 0, 0}, 0xFF0000, 0x00FF00, 0x0000FF };
	m_hdc = CreateCompatibleDC(nullptr);
	m_hbm = CreateDIBSection(m_hdc, (BITMAPINFO*)&b, DIB_RGB_COLORS, nullptr, nullptr, 0);

	BITMAP bm;
	GetObject(m_hbm, sizeof(bm), &bm);
	memset_u32(bm.bmBits, 0xFF000000, bm.bmHeight * bm.bmWidthBytes);

	SetEvent(m_hEvtTransform);
}

bool CDirectVobSubFilter::AdjustFrameSize(CSize& s)
{
	int horizontal, vertical, resx2, resx2minw, resx2minh;
	get_ExtendPicture(&horizontal, &vertical, &resx2, &resx2minw, &resx2minh);

	bool fRet = (resx2 == 1) || (resx2 == 2 && s.cx * s.cy <= resx2minw * resx2minh);

	if (fRet) {
		s.cx <<= 1;
		s.cy <<= 1;
	}

	int h;
	switch (vertical & 0x7f) {
	case 1:
		h = s.cx * 9 / 16;
		if (s.cy < h || !!(vertical & 0x80)) {
			s.cy = (h + 3) & ~3;
		}
		break;
	case 2:
		h = s.cx * 3 / 4;
		if (s.cy < h || !!(vertical & 0x80)) {
			s.cy = (h + 3) & ~3;
		}
		break;
	case 3:
		h = 480;
		if (s.cy < h || !!(vertical & 0x80)) {
			s.cy = (h + 3) & ~3;
		}
		break;
	case 4:
		h = 576;
		if (s.cy < h || !!(vertical & 0x80)) {
			s.cy = (h + 3) & ~3;
		}
		break;
	}

	if (horizontal == 1) {
		s.cx = (s.cx + 31) & ~31;
		s.cy = (s.cy + 1) & ~1;
	}

	return(fRet);
}

STDMETHODIMP CDirectVobSubFilter::Count(DWORD* pcStreams)
{
	if (!pcStreams) {
		return E_POINTER;
	}

	*pcStreams = 0;

	int nLangs = 0;
	if (SUCCEEDED(get_LanguageCount(&nLangs))) {
		(*pcStreams) += nLangs;
	}

	(*pcStreams) += 2; // enable ... disable

	(*pcStreams) += 2; // normal flipped

	return S_OK;
}

#define MAXPREFLANGS 5

int CDirectVobSubFilter::FindPreferedLanguage(bool fHideToo)
{
	int nLangs;
	get_LanguageCount(&nLangs);

	if (nLangs <= 0) {
		return(0);
	}

	for (int i = 0; i < MAXPREFLANGS; i++) {
		CString tmp;
		tmp.Format(L"Lang%d", i);
		CString lang = m_strLang.c_str();
		if (!lang.IsEmpty()) {
			for (int ret = 0; ret < nLangs; ret++) {
				CString l;
				WCHAR* pName = nullptr;
				get_LanguageName(ret, &pName);
				l = pName;
				CoTaskMemFree(pName);

				if (!l.CompareNoCase(lang)) {
					return(ret);
				}
			}
		}
	}

	return(0);
}

void CDirectVobSubFilter::UpdatePreferedLanguages(CString l)
{
	CString langs[MAXPREFLANGS + 1];

	int i = 0, j = 0, k = -1;
	for (; i < MAXPREFLANGS; i++) {
		CString tmp;
		tmp.Format(L"Lang%d", i);
		langs[j] = m_strLang.c_str();
		if (!langs[j].IsEmpty()) {
			if (!langs[j].CompareNoCase(l)) {
				k = j;
			}
			j++;
		}
	}

	if (k == -1) {
		langs[k = j] = l;
		j++;
	}

	// move the selected to the top of the list

	while (k > 0) {
		std::swap(langs[k], langs[k - 1]);
		/*
		CString tmp = langs[k];
		langs[k] = langs[k-1];
		langs[k-1] = tmp;
		*/
		k--;
	}

	// move "Hide subtitles" to the last position if it wasn't our selection

	CString hidesubs = L"Hide Subtitles";

	for (k = 1; k < j; k++) {
		if (!langs[k].CompareNoCase(hidesubs)) {
			break;
		}
	}

	while (k < j - 1) {
		std::swap(langs[k], langs[k + 1]);
		k++;
	}

	for (i = 0; i < j; i++) {
		CString tmp;
		tmp.Format(L"Lang%d", i);
		m_strLang = langs[i];
	}
}

STDMETHODIMP CDirectVobSubFilter::Enable(long lIndex, DWORD dwFlags)
{
	if (!(dwFlags & AMSTREAMSELECTENABLE_ENABLE)) {
		return E_NOTIMPL;
	}

	int nLangs = 0;
	get_LanguageCount(&nLangs);

	if (!(lIndex >= 0 && lIndex < nLangs + 2 + 2)) {
		return E_INVALIDARG;
	}

	int i = lIndex - 1;

	if (i == -1 && !m_bLoading) { // we need this because when loading something stupid media player pushes the first stream it founds, which is "enable" in our case
		put_HideSubtitles(false);
	}
	else if (i >= 0 && i < nLangs) {
		put_HideSubtitles(false);
		put_SelectedLanguage(i);

		WCHAR* pName = nullptr;
		if (SUCCEEDED(get_LanguageName(i, &pName))) {
			UpdatePreferedLanguages(CString(pName));
			if (pName) {
				CoTaskMemFree(pName);
			}
		}
	}
	else if (i == nLangs && !m_bLoading) {
		put_HideSubtitles(true);
	}
	else if ((i == nLangs + 1 || i == nLangs + 2) && !m_bLoading) {
		put_Flip(i == nLangs + 2, m_bFlipSubtitles);
	}

	return S_OK;
}

STDMETHODIMP CDirectVobSubFilter::Info(long lIndex, AM_MEDIA_TYPE** ppmt, DWORD* pdwFlags, LCID* plcid, DWORD* pdwGroup, WCHAR** ppszName, IUnknown** ppObject, IUnknown** ppUnk)
{
	const int FLAG_CMD = 1;
	const int FLAG_EXTERNAL_SUB = 2;
	const int FLAG_PICTURE_CMD = 4;
	const int FLAG_VISIBILITY_CMD = 8;

	int nLangs = 0;
	get_LanguageCount(&nLangs);

	if (lIndex < 0 || lIndex >= nLangs + 2 + 2) {
		return E_INVALIDARG;
	}

	const int idx = lIndex - 1;

	if (ppmt) {
		*ppmt = CreateMediaType(&m_pInput->CurrentMediaType());
	}

	if (pdwFlags) {
		*pdwFlags = 0;

		if (idx == -1 && !m_bHideSubtitles
			|| idx >= 0 && idx < nLangs && idx == m_iSelectedLanguage
			|| idx == nLangs && m_bHideSubtitles
			|| idx == nLangs + 1 && !m_bFlipPicture
			|| idx == nLangs + 2 && m_bFlipPicture) {
			*pdwFlags |= AMSTREAMSELECTINFO_ENABLED;
		}
	}

	if (plcid) {
		*plcid = 0;
	}

	if (pdwGroup) {
		*pdwGroup = 0x648E00;

		if (idx >= 0 && idx < nLangs) {
			const int nExternalLangs = get_ExternalSubstreamsLanguageCount();
			if (idx < nExternalLangs) {
				*pdwGroup |= FLAG_EXTERNAL_SUB;
			}
		}
		else if (idx == -1 || idx == nLangs) {
			*pdwGroup |= FLAG_CMD | FLAG_VISIBILITY_CMD;
		}
		else if (idx == nLangs + 1 || idx == nLangs + 2) {
			*pdwGroup |= FLAG_CMD | FLAG_PICTURE_CMD;
		}
	}

	if (ppszName) {
		*ppszName = nullptr;

		CStringW str;
		if (idx == -1) {
			str = L"Show Subtitles";// ResStr(IDS_M_SHOWSUBTITLES).c_str();
		}
		else if (idx >= 0 && idx < nLangs) {
			get_LanguageName(idx, ppszName);
		}
		else if (idx == nLangs) {
			str = L"Hide Subtitles";// ResStr(IDS_M_HIDESUBTITLES).c_str();
		}
		else if (idx == nLangs + 1) {
			str = L"Original Picture";// ResStr(IDS_M_ORIGINALPICTURE).c_str();
		}
		else if (idx == nLangs + 2) {
			str = L"Flipped Picture";// ResStr(IDS_M_FLIPPEDPICTURE).c_str();
		}

		if (!str.IsEmpty()) {
			*ppszName = (WCHAR*)CoTaskMemAlloc((str.GetLength() + 1) * sizeof(WCHAR));
			if (*ppszName == nullptr) {
				return S_FALSE;
			}
			wcscpy_s(*ppszName, str.GetLength() + 1, str);
		}
	}

	if (ppObject) {
		*ppObject = nullptr;
	}

	if (ppUnk) {
		*ppUnk = nullptr;
	}

	return S_OK;
}

STDMETHODIMP CDirectVobSubFilter::GetClassID(CLSID* pClsid)
{
	if (pClsid == nullptr) {
		return E_POINTER;
	}
	*pClsid = m_clsid;
	return NOERROR;
}

// IDirectVobSub

STDMETHODIMP CDirectVobSubFilter::put_FileName(WCHAR* fn)
{
	HRESULT hr = CDirectVobSub::put_FileName(fn);

	if (hr == S_OK && !Open()) {
		m_FileName.Empty();
		hr = E_FAIL;
	}

	return hr;
}

STDMETHODIMP CDirectVobSubFilter::get_LanguageCount(int* nLangs)
{
	HRESULT hr = CDirectVobSub::get_LanguageCount(nLangs);

	if (hr == NOERROR && nLangs) {
		DSAutoLock cAutolock(&m_csQueueLock);

		*nLangs = 0;
		POSITION pos = m_pSubStreams.GetHeadPosition();
		while (pos) {
			(*nLangs) += m_pSubStreams.GetNext(pos)->GetStreamCount();
		}
	}

	return hr;
}

STDMETHODIMP CDirectVobSubFilter::get_LanguageName(int iLanguage, WCHAR** ppName)
{
	HRESULT hr = CDirectVobSub::get_LanguageName(iLanguage, ppName);

	if (!ppName) {
		return E_POINTER;
	}

	if (hr == NOERROR) {
		DSAutoLock cAutolock(&m_csQueueLock);

		hr = E_INVALIDARG;

		int i = iLanguage;

		POSITION pos = m_pSubStreams.GetHeadPosition();
		while (i >= 0 && pos) {
			CComPtr<ISubStream> pSubStream = m_pSubStreams.GetNext(pos);

			if (i < pSubStream->GetStreamCount()) {
				pSubStream->GetStreamInfo(i, ppName, nullptr);
				hr = NOERROR;
				break;
			}

			i -= pSubStream->GetStreamCount();
		}
	}

	return hr;
}

STDMETHODIMP CDirectVobSubFilter::put_SelectedLanguage(int iSelected)
{
	HRESULT hr = CDirectVobSub::put_SelectedLanguage(iSelected);

	if (hr == NOERROR) {
		UpdateSubtitle(false);
	}

	return hr;
}

STDMETHODIMP CDirectVobSubFilter::put_HideSubtitles(bool fHideSubtitles)
{
	HRESULT hr = CDirectVobSub::put_HideSubtitles(fHideSubtitles);

	if (hr == NOERROR) {
		UpdateSubtitle(false);
	}

	return hr;
}

// deprecated
STDMETHODIMP CDirectVobSubFilter::put_PreBuffering(bool fDoPreBuffering)
{
	HRESULT hr = CDirectVobSub::put_PreBuffering(fDoPreBuffering);

	if (hr == NOERROR && m_pInput && m_pInput->IsConnected()) {
		InitSubPicQueue();
	}

	return hr;
}

STDMETHODIMP CDirectVobSubFilter::put_SubPictToBuffer(unsigned int uSubPictToBuffer)
{
	HRESULT hr = CDirectVobSub::put_SubPictToBuffer(uSubPictToBuffer);

	if (hr == NOERROR && m_pInput && m_pInput->IsConnected()) {
		InitSubPicQueue();
	}

	return hr;
}

STDMETHODIMP CDirectVobSubFilter::put_AnimWhenBuffering(bool fAnimWhenBuffering)
{
	HRESULT hr = CDirectVobSub::put_AnimWhenBuffering(fAnimWhenBuffering);

	if (hr == NOERROR && m_pInput && m_pInput->IsConnected()) {
		InitSubPicQueue();
	}

	return hr;
}

STDMETHODIMP CDirectVobSubFilter::put_AllowDropSubPic(bool fAllowDropSubPic)
{
	HRESULT hr = CDirectVobSub::put_AllowDropSubPic(fAllowDropSubPic);

	if (hr == NOERROR && m_pInput && m_pInput->IsConnected()) {
		InitSubPicQueue();
	}

	return hr;
}

STDMETHODIMP CDirectVobSubFilter::put_Placement(bool fOverridePlacement, int xperc, int yperc)
{
	HRESULT hr = CDirectVobSub::put_Placement(fOverridePlacement, xperc, yperc);

	if (hr == NOERROR) {
		UpdateSubtitle();
	}

	return hr;
}

STDMETHODIMP CDirectVobSubFilter::put_VobSubSettings(bool fBuffer, bool fOnlyShowForcedSubs, bool fReserved)
{
	HRESULT hr = CDirectVobSub::put_VobSubSettings(fBuffer, fOnlyShowForcedSubs, fReserved);

	if (hr == NOERROR) {
		//		UpdateSubtitle(false);
		InvalidateSubtitle();
	}

	return hr;
}

STDMETHODIMP CDirectVobSubFilter::put_TextSettings(void* lf, int lflen, COLORREF color, bool fShadow, bool fOutline, bool fAdvancedRenderer)
{
	HRESULT hr = CDirectVobSub::put_TextSettings(lf, lflen, color, fShadow, fOutline, fAdvancedRenderer);

	if (hr == NOERROR) {
		//		UpdateSubtitle();
		InvalidateSubtitle();
	}

	return hr;
}

STDMETHODIMP CDirectVobSubFilter::put_SubtitleTiming(int delay, int speedmul, int speeddiv)
{
	HRESULT hr = CDirectVobSub::put_SubtitleTiming(delay, speedmul, speeddiv);

	if (hr == NOERROR) {
		InvalidateSubtitle();
	}

	return hr;
}

STDMETHODIMP CDirectVobSubFilter::get_MediaFPS(bool* fEnabled, double* fps)
{
	HRESULT hr = CDirectVobSub::get_MediaFPS(fEnabled, fps);

	CComQIPtr<IMediaSeeking> pMS = m_pGraph;
	double rate;
	if (pMS && SUCCEEDED(pMS->GetRate(&rate))) {
		m_MediaFPS = rate * m_fps;
		if (fps) {
			*fps = m_MediaFPS;
		}
	}

	return hr;
}

STDMETHODIMP CDirectVobSubFilter::put_MediaFPS(bool fEnabled, double fps)
{
	HRESULT hr = CDirectVobSub::put_MediaFPS(fEnabled, fps);

	CComQIPtr<IMediaSeeking> pMS = m_pGraph;
	if (pMS) {
		if (hr == NOERROR) {
			hr = pMS->SetRate(m_bMediaFPSEnabled ? m_MediaFPS / m_fps : 1.0);
		}

		double dRate;
		if (SUCCEEDED(pMS->GetRate(&dRate))) {
			m_MediaFPS = dRate * m_fps;
		}
	}

	return hr;
}

STDMETHODIMP CDirectVobSubFilter::get_ZoomRect(NORMALIZEDRECT* rect)
{
	return E_NOTIMPL;
}

STDMETHODIMP CDirectVobSubFilter::put_ZoomRect(NORMALIZEDRECT* rect)
{
	return E_NOTIMPL;
}

// IDirectVobSub2

STDMETHODIMP CDirectVobSubFilter::put_TextSettings(STSStyle* pDefStyle)
{
	HRESULT hr = CDirectVobSub::put_TextSettings(pDefStyle);

	if (hr == NOERROR) {
		UpdateSubtitle();
	}

	return hr;
}

STDMETHODIMP CDirectVobSubFilter::put_AspectRatioSettings(EPARCompensationType* ePARCompensationType)
{
	HRESULT hr = CDirectVobSub::put_AspectRatioSettings(ePARCompensationType);

	if (hr == NOERROR) {
		UpdateSubtitle(false);
	}

	return hr;
}

// IDirectVobSub3

STDMETHODIMP CDirectVobSubFilter::get_LanguageType(int iLanguage, int* pType)
{
	HRESULT hr = E_INVALIDARG;
	WCHAR* pName;
	if (pType && SUCCEEDED(hr = get_LanguageName(iLanguage, &pName)) && pName) {
		*pType = 0;
		CoTaskMemFree(pName);

		int nLangs = 0;
		get_LanguageCount(&nLangs);

		int nEmbeddedCount = 0;
		for (const auto& pTextInput : m_pTextInputs) {
			if (pTextInput->IsConnected()) {
				CComPtr<ISubStream> pSubStream = pTextInput->GetSubStream();
				nEmbeddedCount += pSubStream->GetStreamCount();
			}
		}

		nLangs -= nEmbeddedCount;

		if (iLanguage < nLangs) {
			*pType = 1;
		}
	}

	return hr;
}


// IDirectVobSubFilterColor

STDMETHODIMP CDirectVobSubFilter::HasConfigDialog(int iSelected)
{
	int nLangs;
	if (FAILED(get_LanguageCount(&nLangs))) {
		return E_FAIL;
	}
	return E_FAIL;
	// TODO: temporally disabled since we don't have a new textsub/vobsub editor dlg for dvs yet
	//	return(nLangs >= 0 && iSelected < nLangs ? S_OK : E_FAIL);
}

STDMETHODIMP CDirectVobSubFilter::ShowConfigDialog(int iSelected, HWND hWndParent)
{
	// TODO: temporally disabled since we don't have a new textsub/vobsub editor dlg for dvs yet
	return(E_FAIL);
}



///////////////////////////////////////////////////////////////////////////////

bool CDirectVobSubFilter::Open()
{
	DSAutoLock cAutolock(&m_csQueueLock);

	m_pSubStreams.RemoveAll();

	m_frd.files.clear();

	m_bExternalSubtitle = false;
	m_ExternalSubstreams.clear();

	std::vector<CString> paths;

	for (int i = 0; i < 10; i++) {
		CString path = L".";
		if (!path.IsEmpty()) {
			paths.push_back(path);
		}
	}

	std::vector<CString> ret;
	Subtitle::GetSubFileNames(m_FileName, paths, ret);

	for (const auto& sub_fn : ret) {
		if (Contains(m_frd.files, sub_fn)) {
			continue;
		}

		const CStringW ext = GetFileExt(sub_fn).MakeLower();
		CComPtr<ISubStream> pSubStream;

		try {
			if (!pSubStream && ext == L".sup") {
				std::unique_ptr<CRenderedHdmvSubtitle> pRHS(new CRenderedHdmvSubtitle(&m_csSubLock));
				if (pRHS->Open(sub_fn, L"", m_videoFileName)) {
					pSubStream = pRHS.release();
				}
			}

			if (!pSubStream && ext == L".idx") {
				std::unique_ptr<CVobSubFile> pVSF(new CVobSubFile(&m_csSubLock));
				if (pVSF->Open(sub_fn) && pVSF->GetStreamCount() > 0) {
					pSubStream = pVSF.release();
					m_frd.files.push_back(sub_fn.Left(sub_fn.GetLength() - 4) + L".sub");
				}
			}

			if (!pSubStream) {
				std::unique_ptr<CRenderedTextSubtitle> pRTS(new CRenderedTextSubtitle(&m_csSubLock));
				if (pRTS->Open(sub_fn, DEFAULT_CHARSET, L"", m_videoFileName) && pRTS->GetStreamCount() > 0) {
					pSubStream = pRTS.release();
					m_frd.files.push_back(sub_fn + L".style");
				}
			}
		}
		catch (CException* e) {
			e->Delete();
		}

		if (pSubStream) {
			m_pSubStreams.AddTail(pSubStream);
			m_frd.files.push_back(sub_fn);

			m_ExternalSubstreams.push_back(pSubStream);
		}
	}

	for (const auto& pTextInput : m_pTextInputs) {
		if (pTextInput->IsConnected()) {
			m_pSubStreams.AddTail(pTextInput->GetSubStream());
		}
	}

	if (S_FALSE == put_SelectedLanguage(FindPreferedLanguage())) {
		UpdateSubtitle(false);    // make sure pSubPicProvider of our queue gets updated even if the stream number hasn't changed
	}

	m_frd.RefreshEvent.Set();

	return(m_pSubStreams.GetCount() > 0);
}

void CDirectVobSubFilter::UpdateSubtitle(bool fApplyDefStyle)
{
	DSAutoLock cAutolock(&m_csQueueLock);

	if (!m_pSubPicQueue) {
		return;
	}

	InvalidateSubtitle();

	CComPtr<ISubStream> pSubStream;

	if (!m_bHideSubtitles) {
		int i = m_iSelectedLanguage;

		for (POSITION pos = m_pSubStreams.GetHeadPosition(); i >= 0 && pos; pSubStream = nullptr) {
			pSubStream = m_pSubStreams.GetNext(pos);

			if (i < pSubStream->GetStreamCount()) {
				DSAutoLock cAutoLock(&m_csSubLock);
				pSubStream->SetStream(i);
				break;
			}

			i -= pSubStream->GetStreamCount();
		}
	}

	SetSubtitle(pSubStream, fApplyDefStyle);
}

void CDirectVobSubFilter::SetSubtitle(ISubStream* pSubStream, bool fApplyDefStyle)
{
	DSAutoLock cAutolock(&m_csQueueLock);

	if (pSubStream) {
		DSAutoLock cAutolock(&m_csSubLock);

		CLSID clsid;
		pSubStream->GetClassID(&clsid);

		if (clsid == __uuidof(CVobSubFile) || clsid == __uuidof(CVobSubStream)) {
			if (auto pVSS = dynamic_cast<CVobSubSettings*>(pSubStream)) {
				pVSS->SetAlignment(m_bOverridePlacement, m_PlacementXperc, m_PlacementYperc);
				pVSS->m_bOnlyShowForcedSubs = m_bOnlyShowForcedVobSubs;
			}
		}
		else if (clsid == __uuidof(CRenderedTextSubtitle)) {
			CRenderedTextSubtitle* pRTS = (CRenderedTextSubtitle*)pSubStream;

			if (fApplyDefStyle || pRTS->m_fUsingAutoGeneratedDefaultStyle) {
				STSStyle s = m_defStyle;

				if (m_bOverridePlacement) {
					s.scrAlignment = 2;
					int w = pRTS->m_dstScreenSize.cx;
					int h = pRTS->m_dstScreenSize.cy;
					int mw = w - s.marginRect.left - s.marginRect.right;
					s.marginRect.bottom = h - MulDiv(h, m_PlacementYperc, 100);
					s.marginRect.left = MulDiv(w, m_PlacementXperc, 100) - mw / 2;
					s.marginRect.right = w - (s.marginRect.left + mw);
				}

				pRTS->SetDefaultStyle(s);
			}

			pRTS->m_ePARCompensationType = m_ePARCompensationType;
			if (m_CurrentVIH2.dwPictAspectRatioX != 0 && m_CurrentVIH2.dwPictAspectRatioY != 0 && m_CurrentVIH2.bmiHeader.biWidth != 0 && m_CurrentVIH2.bmiHeader.biHeight != 0) {
				pRTS->m_dPARCompensation = ((double)abs(m_CurrentVIH2.bmiHeader.biWidth) / (double)abs(m_CurrentVIH2.bmiHeader.biHeight)) /
					((double)abs((long)m_CurrentVIH2.dwPictAspectRatioX) / (double)abs((long)m_CurrentVIH2.dwPictAspectRatioY));

			}
			else {
				pRTS->m_dPARCompensation = 1.00;
			}

			pRTS->Deinit();
		}

		const CMediaType& mt = m_pOutput->CurrentMediaType();
		DXVA2_ExtendedFormat extFormat; extFormat.value = 0;
		if (mt.formattype == FORMAT_VideoInfo2) {
			extFormat.value = ((VIDEOINFOHEADER2*)mt.Format())->dwControlFlags;
		}
		CString yuvMatrix = extFormat.VideoTransferMatrix == DXVA2_VideoTransferMatrix_BT601 ? L"601" : L"709";
		CString inputRange = extFormat.NominalRange == DXVA2_NominalRange_Normal ? L"PC" : L"TV";
		CString outpuRange(L"PC");

		pSubStream->SetSourceTargetInfo(yuvMatrix, inputRange, outpuRange);
	}

	if (!fApplyDefStyle) {
		int i = 0;

		POSITION pos = m_pSubStreams.GetHeadPosition();
		while (pos) {
			CComPtr<ISubStream> pSubStream2 = m_pSubStreams.GetNext(pos);

			if (pSubStream == pSubStream2) {
				m_iSelectedLanguage = i + pSubStream2->GetStream();
				break;
			}

			i += pSubStream2->GetStreamCount();
		}
	}

	m_nSubtitleId = (DWORD_PTR)pSubStream;

	if (m_pSubPicQueue) {
		m_bExternalSubtitle = (Contains(m_ExternalSubstreams, pSubStream));

		m_pSubPicQueue->SetSubPicProvider(CComQIPtr<ISubPicProvider>(pSubStream));
	}
}

void CDirectVobSubFilter::InvalidateSubtitle(REFERENCE_TIME rtInvalidate, DWORD_PTR nSubtitleId)
{
	DSAutoLock cAutolock(&m_csQueueLock);

	if (m_pSubPicQueue) {
		if (nSubtitleId == -1 || nSubtitleId == m_nSubtitleId) {
			m_pSubPicQueue->Invalidate(rtInvalidate);
		}
	}
}

//////////////////////////////////////////////////////////////////////////////////////////

void CDirectVobSubFilter::AddSubStream(ISubStream* pSubStream)
{
	DSAutoLock cAutoLock(&m_csQueueLock);

	POSITION pos = m_pSubStreams.Find(pSubStream);
	if (!pos) {
		m_pSubStreams.AddTail(pSubStream);
	}

	int len = m_pTextInputs.size();
	for (const auto& pTextInput : m_pTextInputs) {
		if (pTextInput->IsConnected()) {
			len--;
		}
	}

	if (len == 0) {
		HRESULT hr = S_OK;
		m_pTextInputs.push_back(new CTextInputPin(this, m_pLock, &m_csSubLock, &hr));
	}
}

void CDirectVobSubFilter::RemoveSubStream(ISubStream* pSubStream)
{
	DSAutoLock cAutoLock(&m_csQueueLock);

	POSITION pos = m_pSubStreams.Find(pSubStream);
	if (pos) {
		m_pSubStreams.RemoveAt(pos);
	}
}

void CDirectVobSubFilter::Post_EC_OLE_EVENT(CString str, DWORD_PTR nSubtitleId)
{
	if (nSubtitleId != -1 && nSubtitleId != m_nSubtitleId) {
		return;
	}

	CComQIPtr<IMediaEventSink> pMES = m_pGraph;
	if (!pMES) {
		return;
	}

	CComBSTR bstr1("Text"), bstr2(" ");

	str.Trim();
	if (!str.IsEmpty()) {
		bstr2 = CStringA(str);
	}

	pMES->Notify(EC_OLE_EVENT, (LONG_PTR)bstr1.Detach(), (LONG_PTR)bstr2.Detach());
}

////////////////////////////////////////////////////////////////

void CDirectVobSubFilter::SetupFRD(CStringArray& paths, std::vector<HANDLE>& handles)
{
	DSAutoLock cAutolock(&m_csSubLock);

	for (size_t i = 2; i < handles.size(); i++) {
		FindCloseChangeNotification(handles[i]);
	}

	paths.RemoveAll();
	handles.clear();

	handles.push_back(m_frd.EndThreadEvent);
	handles.push_back(m_frd.RefreshEvent);

	m_frd.mtime.resize(m_frd.files.size());

	auto it = m_frd.files.begin();
	for (size_t i = 0; it != m_frd.files.end(); i++) {
		CString fn = *it++;

		CFileStatus status;
		if (CFileGetStatus(fn, status)) {
			m_frd.mtime[i] = status.m_mtime;
		}

		fn.Replace('\\', '/');
		fn = fn.Left(fn.ReverseFind('/') + 1);

		bool fFound = false;

		for (INT_PTR j = 0; !fFound && j < paths.GetCount(); j++) {
			if (paths[j] == fn) {
				fFound = true;
			}
		}

		if (!fFound) {
			paths.Add(fn);

			HANDLE h = FindFirstChangeNotificationW(fn, FALSE, FILE_NOTIFY_CHANGE_LAST_WRITE);
			if (h != INVALID_HANDLE_VALUE) {
				handles.push_back(h);
			}
		}
	}
}

DWORD CDirectVobSubFilter::ThreadProc()
{
	SetThreadPriority(m_hThread, THREAD_PRIORITY_LOWEST/*THREAD_PRIORITY_BELOW_NORMAL*/);

	CStringArray paths;
	std::vector<HANDLE> handles;

	SetupFRD(paths, handles);

	for (;;) {
		DWORD idx = WaitForMultipleObjects(handles.size(), handles.data(), FALSE, INFINITE);

		if (idx == (WAIT_OBJECT_0 + 0)) { // m_frd.hEndThreadEvent
			break;
		}
		if (idx == (WAIT_OBJECT_0 + 1)) { // m_frd.hRefreshEvent
			SetupFRD(paths, handles);
		}
		else if (idx >= (WAIT_OBJECT_0 + 2) && idx < (WAIT_OBJECT_0 + handles.size())) {
			bool fLocked = true;
			IsSubtitleReloaderLocked(&fLocked);
			if (fLocked) {
				continue;
			}

			if (FindNextChangeNotification(handles[idx - WAIT_OBJECT_0]) == FALSE) {
				break;
			}

			int j = 0;

			auto it = m_frd.files.begin();
			for (size_t i = 0; it != m_frd.files.end() && j == 0; i++) {
				CString fn = *it++;

				CFileStatus status;
				if (CFileGetStatus(fn, status) && m_frd.mtime[i] != status.m_mtime) {
					for (j = 0; j < 10; j++) {
						FILE* f = nullptr;
						if (_wfopen_s(&f, fn, L"rb+") == 0) {
							fclose(f);
							j = 0;
							break;
						}
						else {
							Sleep(100);
							j++;
						}
					}
				}
			}

			if (j > 0) {
				SetupFRD(paths, handles);
			}
			else {
				Sleep(500);

				auto it = m_frd.files.begin();
				for (size_t i = 0; it != m_frd.files.end(); i++) {
					CFileStatus status;
					if (CFileGetStatus(*it++, status)
						&& m_frd.mtime[i] != status.m_mtime) {
						Open();
						SetupFRD(paths, handles);
						break;
					}
				}
			}
		}
		else {
			break;
		}
	}

	for (size_t i = 2; i < handles.size(); i++) {
		FindCloseChangeNotification(handles[i]);
	}

	return 0;
}

int CDirectVobSubFilter::get_ExternalSubstreamsLanguageCount()
{
	int nCount = 0;
	if (!m_ExternalSubstreams.empty()) {
		DSAutoLock cAutolock(&m_csQueueLock);

		POSITION pos = m_pSubStreams.GetHeadPosition();
		while (pos) {
			auto pSubStream = m_pSubStreams.GetNext(pos);
			if (Contains(m_ExternalSubstreams, pSubStream.p)) {
				nCount += pSubStream->GetStreamCount();
			}
		}
	}

	return nCount;
}

